<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F01%2FDocker%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[IDEA导入项目报错non-managed pom.xml file found]]></title>
    <url>%2F2019%2F08%2F16%2FIDEA-bug%2F</url>
    <content type="text"><![CDATA[第一步：点击右侧的maven视图 第二步：选择需要添加的pox.xml文件 第三步：选择项目运行需要的SDK OVER]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD认知(下)]]></title>
    <url>%2F2019%2F08%2F12%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[一、转换操作(续) 函数 解释 示例 def aggregateByKey[U:ClassTag](zeroValue:U,partitioner:Partitioner)(seqOp:(U,V)=&gt;U,combOp:(U,U)=&gt;U):RDD[(K,U)] 通过seqOp函数将每一个分区里面的数据和初始值迭代带入函数返回最终值，comOp将每一个分区返回的最终值根据key进行合并操作 略 def foldByKey(zeroValue:V,partitioner:Partitioner)(func:(V,V)=&gt;V):RDD[(K,V)] aggregateByKey的简化操作，seqop和combop相同 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)val agg = rdd.foldByKey(0)(+).collect def sortByKey(ascending:Boolean=true,numPartitions:Int=self.partitions.length):RDD[(K,V)] 在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD val rdd = sc.parallelize(Array((3,”aa”),(6,”cc”),(2,”bb”),(1,”dd”))) rdd.sortByKey(true).collect() def sortBy[K](f:(T)=&gt;K,ascending:Boolean=true,numPartitions:Int = this.partitions.length)(implicit ord:Ordering[K],ctag:ClassTag[K]):RDD[T] 底层实现还是使用sortByKey，只不过使用fun生成的新key进行排序 val rdd = sc.parallelize(List(1,2,3,4)) rdd.sortBy(x =&gt; x%3).collect() def join[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(V,W))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD val rdd1= sc.parallelize(Array((1,”a”),(2,”b”),(3,”c”)))) val rdd2 = sc.parallelize(Array((1,4),(2,5),(3,6))) rdd1.join(rdd2).collect() def cogroup[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(Iterable[V], Iterable[W]))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable,Iterable))类型的RDD 略 def cartesian[U:ClassTag](other:RDD[U]):RDD[(T,U)] 笛卡尔积 val rdd1 = sc.parallelize(1 to 3) val rdd2 = sc.parallelize(2 to 5) rdd1.cartesian(rdd2).collect() def pipe(command:String):RDD[String] 对于每个分区，都执行一个perl或者shell脚本，返回输出的RDD 略 def coalesce(numPartitions:Int,shuffle:Boolean=false,partitionCoalescer: Option[PartitionCoalescer]=Option.empty)(implicit ord:Ordering[T]=null):RDD[T] 缩减分区数，用于大数据集过滤后，提高小数据集的执行效率 略 def repartition(numPartitions:Int)(implicit ord:Ordering[T]=null):RDD[T] 根据分区数,重新通过网络随机洗牌所有数据 略 def repartitionAndSortWithinPartitions(partitioner:Partitioner):RDD[(K,V)] repartitionAndSortWithinPartitions函数是repartition函数的变种，与repartition函数不同的是，repartitionAndSortWithinPartitions在给定的partitioner内部进行排序，性能比repartition要高 略 def glom():RDD[Array[T]] 将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]] val rdd = sc.parallelize(1 to 16,4) rdd.glom().collect() def mapValues[U](f:V=&gt;U):RDD[(K,U)] 针对于(K,V)形式的类型只对V进行操作 val rdd3 = sc.parallelize(Array((1,”a”),(1,”d”),(2,”b”),(3,”c”))) rdd3.mapValues(_+”|||”).collect() def subtract(other:RDD[T]):RDD[T] 计算差的一种函数去除两个RDD中相同的元素，不同的RDD将保留下来 val rdd = sc.parallelize(3 to 8) val rdd1 = sc.parallelize(1 to 5) rdd.subtract(rdd1).collect() 二、行动操作 函数 解释 示例 def takeSample(withReplacement:Boolean,num:Int,seed:Long=Utils.random.nextLong):Array[T] 返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子 val rdd=sc.parallelize(1 to 10,2)rdd.takeSample(true,5,3) def reduce(f:(T,T)=&gt;T):T 通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的 val rdd1 = sc.makeRDD(1 to 10,2) rdd1.reduce(+) def collect():Array[T] 在驱动程序中，以数组的形式返回数据集的所有元素 太常用，略 def count():Long 返回RDD的元素个数 略 def first():T 返回RDD的第一个元素（类似于take(1)) 略 def take(num:Int):Array[T] 返回一个由数据集的前n个元素组成的数组 略 def takeOrdered(num:Int)(implicit ord:Ordering[T]) 返回前几个的排序 略 def aggregate[U:ClassTag](zeroValue:U)(seqOp:(U,T)=&gt;U,combOp:(U,U)=&gt;U):U aggregate函数将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。这个函数最终返回的类型不需要和RDD中元素类型一致 scala&gt; var rdd1 = sc.makeRDD(1 to 10,2) scala&gt;rdd1.aggregate(1){(x : Int,y : Int) =&gt; x + y}, {(a : Int,b : Int) =&gt; a + b}) def fold(zeroValue:T)(op:(T,T)=&gt;T):T 折叠操作，aggregate的简化操作，seqop和combop一样 var rdd1 = sc.makeRDD(1 to 4,2) rdd1.fold(1)(+) def saveAsTextFile(path:String):Unit 将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本 略 def saveAsObjectFile(path:String):Unit 用于将RDD中的元素序列化成对象，存储到文件中 略 def countByKey():Map[K,Long] 针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)rdd.countByKey() def foreach(f:T=&gt;Unit):Unit 在数据集的每一个元素上，运行函数func进行更新 var rdd = sc.makeRDD(1 to 10,2) var sum = sc.accumulator(0) rdd.foreach(sum+=_) 注意：当在RDD中使用到了class的方法或者属性的时候，该class需要继承java.io.Serializable接口，或者可以将属性赋值为本地变量来防止整个对象的传输]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD的认知（上）]]></title>
    <url>%2F2019%2F08%2F11%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[一、转换操作 函数 解释 案例 def map[U:ClassTag](f:T =&gt; U):RDD[U] 将函数应用于RDD的每一个元素，并返回一个新的RDD val rdd=sc.makeRDD(Array(1,2,3,4,5)) rdd.map((_,1)).collect def filter(f:T =&gt; Boolean):RDD[T] 通过提供的产生boolean条件的表达式来返回符合结果为True的新的RDD val rdd=sc.makeRDD(Array(“aa1”,”aa2”,”bb1”,”bb2”)) rdd.filter(_.startsWith(“aa”)).collect def flatMap[U: ClassTag](f: T =&gt; TraversableOnce[U]): RDD[U] 将函数应用于RDD中的每一项，对于每一项都产生一个集合，并将集合中的元素压扁成一个集合 val rdd=makeRDD(1 to 3) rdd.flatMap((1 to _)).collect def mapPartitions[U:ClassTag](f:Iterator[T] =&gt;Iterator[U],preservesPartitioning:Boolean=false): RDD[U] 将函数应用于RDD的每一个分区，每一个分区运行一次，函数需要能够接受Iterator类型，然后返回Iterator 略 def mapPartitionsWithIndex[U:ClassTag](f:(Int,Iterator[T])=&gt;Iterator[U],preservesPartitioning:Boolean =false):RDD[U] 将函数应用于RDD中的每一个分区，每一个分区运行一次，函数能够接受 一个分区的索引值 和一个代表分区内所有数据的Iterator类型，需要返回Iterator类型 略 def sample(withReplacement: Boolean,fraction:Double,seed:Long=Utils.random.nextLong): RDD[T] 在RDD中以seed为种子返回大致上有fraction比例个数据样本RDD，withReplacement表示是否采用放回式抽样 val sample=sc.makeRDD(1 to 100) sample.sample(false,0.1,4).collect sample.sample(true,0.1,4).collect def union(other:RDD[T]):RDD[T] 将两个RDD中的元素进行合并，返回一个新的RDD val a=sc.makeRDD(1 to 10) sc.makeRDD(5 to 15).union(a).collect def intersection(other:RDD[T]):RDD[T] 将两个RDD做交集，返回一个新的RDD val a=sc.makeRDD(1 to 10) val b=sc.makeRDD(5 to 15) a.intersection(b).collect def distinct():RDD[T] 将当前RDD进行去重后，返回一个新的RDD val dis=sc.makeRDD(List(1,2,3,4,5,2,3,4,1,6,4)） dis.distinct.collect def partitionBy(partitioner:Partitioner):RDD[(K,V)] 根据设置的分区器重新将RDD进行分区，返回新的RDD val par=sc.makeRDD(List((1,”a”),(2,”b”),(3,”c”)),4） par.partitionBy(new org.apache.spark.HashPatitioner(2)) def reduceByKey(func:(V,V)=&gt;V):RDD[(K,V)] 根据Key值将相同Key的元组的值用func进行计算，返回新的RDD val rdd = sc.parallelize(Array(1,2,3,1,2)) rdd.map((,1)) res0.reduceByKey(+_) def groupByKey():RDD[(K,Iterable[V])] 将相同Key的值进行聚集，输出一个(K, Iterable[V])类型的RDD val words=Array(“one”,”one”,”two”,”three”,”three”,”three”) val wordPair=sc.parallelize(words).map((_,1)) val group=wordPair.groupByKey() val map=group.map(t=&gt;(t._1,t._2.sum)) def combineByKey[C](createCombiner:V=&gt;C,mergeValue:(C,V)=&gt; C,mergeCombiners:(C,C)=&gt;C,numPartitions:Int):RDD[(K,C)] 对相同K，把V合并成一个集合.createCombiner: combineByKey()会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过，要么就和之前的某个元素的键相同。如果这是一个新的元素,combineByKey()会使用一个叫作 createCombiner() 的函数来创建那个键对应的累加器的初始值mergeValue:如果这是一个在处理当前分区之前已经遇到的键,它会使用 mergeValue()方法将该键的累加器对应的当前值与这个新的值进行合并mergeCombiners:由于每个分区都是独立处理的，因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器，就需要使用用户提供的 mergeCombiners()方法将各个分区的结果进行合并。 scala&gt; val scores = Array((&quot;Fred&quot;, 88), (&quot;Fred&quot;, 95), (&quot;Fred&quot;, 91), (&quot;Wilma&quot;, 93), (&quot;Wilma&quot;, 95), (&quot;Wilma&quot;, 98)) scores: Array[(String, Int)] = Array((Fred,88), (Fred,95), (Fred,91), (Wilma,93), (Wilma,95), (Wilma,98)) scala&gt; val input = sc.parallelize(scores) input: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[52] at parallelize at &lt;console&gt;:26 scala&gt; val combine = input.combineByKey( ` 待续]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SparkSQL中RDD和DataFrame和DataSet的转换]]></title>
    <url>%2F2019%2F08%2F10%2FRDD%E3%80%81DF%E3%80%81DS%2F</url>
    <content type="text"><![CDATA[RDD ——&gt;DF/DS ——DF: 12345678910//第一种rdd.map&#123; x=&gt;val pa = x.split(&quot;,&quot;);(pa(0).trim,pa(1).trim)&#125;.toDF(&quot;name&quot;,&quot;age&quot;)//-------------------------------------------------------//第二种case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDF ——DS: 1234case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDS DF——RDD/DF ——RDD: DF.rdd获取值，编译器不校验类型 ——DS: 12case class People(name:String,age:Integer)DF.as[People] DS——RDD/DF ——RDD: DS.rdd获取值，编译器校验类型 ——DF: DS.toDF即可]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git——The requested URL returned error 403]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、问题描述hexo部署的仓库需要换到另一个账号上，于是按照之前创建的步骤，修改了hexo安装目录下的deploy的repo地址，然而hexo s和hexo g没出错，但是hexo d时，会出错。 二、问题分析 有可能是你真的没有权限 有可能是修改了git仓库密码和用户名，导致本地内存和硬盘中的用户名和密码不能用 三、问题处理 执行git config --list ，查看git的配置信息 图中的user.email和user.name分别是登录的邮箱和用户名。 打开控制面板-&gt;用户账户-&gt;管理Windows凭据，向下看有普通凭据，找到关于git:https://github.com并删除。 然而我是通过这种方法成功的。 1234//先去根目录root@wangxiaozhang:~/blog cd//再执行来查看credential中缓存的用户root@wangxiaozhang:~# vi .git-credentials 这时我发现这里的代码是我准备要替换的账号名和密码，于是立刻改成现在用的账户名和密码，之后hexo d成功！]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark安装]]></title>
    <url>%2F2019%2F08%2F05%2FSpark%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Spark安装地址 官网地址 http://spark.apache.org 文档查看地址 http://spark.apache.org/docs 下载地址 https://spark.apache.org/downloads.html Standalone模式安装 上传并解压spark安装包 tar -zxvf /opt/softwares/spark-2.4.3-bin-hadoop2.7.tgz -C /opt/module/ 进入spark安装目录下的conf文件夹 cd spark-2.4.3-bin-hadoop2.7/conf 修改配置文件 mv slaves.template slaves mv spark-env.sh.template spark-env.sh 修改slave文件，添加work节点 vi slaves hadoop101 hadoop102 hadoop103 修改spark-env.sh文件，添加如下配置 vi spark-env.sh SPARK_MASTER_HOST=hadoop101 SPARK_MASTER_PROT=7077 分发spark包到其他虚拟机 xsync spark-2.4.3-bin-hadoop2.7 (附分发shell脚本xsync) 12345678910111213141516171819202122232425#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do #echo $pdir/$fname $user@hadoop$host:$pdir echo --------------- hadoop$host ---------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 启动 sbin/start-all.sh 123456789101112131415161718192021[wangzichen@hadoop101 spark-2.4.3-bin-hadoop2.7]$ jps.sh ================wangzichen@hadoop101================3330 Jps3238 Worker3163 Master================wangzichen@hadoop102================2966 Jps2908 Worker================wangzichen@hadoop103================2978 Worker3036 Jps 启动spark shell 1234/opt/module/spark-2.4.3-bin-hadoop2.7/bin/spark-shell \--master spark://hadoop101:7077 \--executor-memory 1g \--total-executor-cores 2 注意：如果启动spark shell时没有指定master地址，但是也可以正常启动spark shell和执行spark shell中的程序，其实是启动了spark的local模式，该模式仅在本机启动一个进程，没有与集群建立联系 。 Spark Shell中已经默认将SparkContext类初始化为对象sc。用户代码如果需要用到，则直接应用sc即可 。 JobHistoryServer配置 修改spark-default.conf.template名称 mv spark-defaults.conf.template spark-defaults.conf 修改spark-default.conf文件，开启log 123vi spark-defaults.confspark.eventLog.enabled //truespark.eventLog.dir //hdfs://hadoop101:9000/directory（若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错） 注意：HDFS上的目录需要提前存在 修改spark-env.sh文件，添加如下配置 1234vi spark-env.shexport SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://hadoop101:9000/directory&quot; //若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错 分发配置文件到其他虚拟机 12xsync spark-defaults.confxsync spark-env.sh 启动历史服务 sbin/start-history-server.sh 测试，执行任务长度 1234567bin/spark-submit \--class org.apache.spark.examples.SparkPi \--master spark://hadoop101:7077 \--executor-memory 1G \--total-executor-cores 2 \./examples/jars/spark-examples_2.11-2.4..jar \100 查看历史服务 在浏览器上输入hadoop101:4000查看 Yarn模式安装 修改hadoop配置文件yarn-site.xml，并添加如下内容 1234567891011vi yarn-site.xml&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; 修改spark-env.sh，添加如下配置 123vi spark-env.shYARN_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop HADOOP_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop 分发配置文件 12xsync /opt/module/hadoop-2.7.2/etc/hadoop/yarn-site.xmlxsync spark-env.sh]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark初识]]></title>
    <url>%2F2019%2F08%2F04%2FSpark%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spark简介(官网的解释Spark官网) Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。项目是用Scala进行编写。 Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLib、SparkR等子项目，Spark是基于内存计算的大数据并行计算框架。除了扩展了广泛使用的 MapReduce 计算模型，而且高效地支持更多计算模式，包括交互式查询和流处理。Spark 适用于各种各样原先需要多种不同的分布式平台的场景，包括批处理、迭代算法、交互式查询、流处理。通过在一个统一的框架下支持这些不同的计算，Spark 使我们可以简单而低耗地把各种处理流程整合在一起。而这样的组合，在实际的数据分析 过程中是很有意义的。不仅如此，Spark 的这种特性还大大减轻了原先需要对各种平台分 别管理的负担。 大一统的软件栈，各个组件关系密切并且可以相互调用，这种设计有几个好处：1、软件栈中所有的程序库和高级组件 都可以从下层的改进中获益。2、运行整个软件栈的代价变小了。不需要运 行 5 到 10 套独立的软件系统了，一个机构只需要运行一套软件系统即可。系统的部署、维护、测试、支持等大大缩减。3、能够构建出无缝整合不同处理模型的应用。 Spark内置项目如下： Spark Core:实现了 Spark 的基本功能，包含任务调度、内存管理、错误恢复、与存储系统 交互等模块。Spark Core 中还包含了对弹性分布式数据集(resilient distributed dataset，简称RDD)的 API 定义 。 Spark SQL:是 Spark 用来操作结构化数据的程序包。通过 Spark SQL，我们可以使用 SQL 或者 Apache Hive 版本的 SQL 方言(HQL)来查询数据。Spark SQL 支持多种数据源，比 如 Hive 表、Parquet 以及 JSON 等。 Spark Streaming:是 Spark 提供的对实时数据进行流式计算的组件。提供了用来操作数据流的 API，并且与 Spark Core 中的 RDD API 高度对应。 Spark MLlib:提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 Spark特点 快：与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中的。 易用：Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用：Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。 兼容性：Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 Spark角色及运行模式集群角色从物理部署层面上来看，Spark主要分为两种类型的节点，Master节点和Worker节点：Master节点主要运行集群管理器的中心化部分，所承载的作用是分配Application到Worker节点，维护Worker节点，Driver，Application的状态。Worker节点负责具体的业务运行。 从Spark程序运行的层面来看，Spark主要分为驱动器节点和执行器节点。 运行模式 Local模式：Local模式就是运行在一台计算机上的模式，通常就是用于在本机上练手和测试。它可以通过以下集中方式设置master。 local: 所有计算都运行在一个线程当中，没有任何并行计算，通常我们在本机执行一些测试代码，或者练手，就用这种模式; local[K]: 指定使用几个线程来运行计算，比如local[4]就是运行4个worker线程。通常我们的cpu有几个core，就指定几个线程，最大化利用cpu的计算能力; local[*]: 这种模式直接帮你按照cpu最多cores来设置线程数了。 Standalone模式：构建一个由Master+Slave构成的Spark集群，Spark运行在集群中。 Yarn模式：Spark客户端直接连接Yarn；不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。 yarn-client：Driver程序运行在客户端，适用于交互、调试，希望立即看到app的输出。 yarn-cluster：Driver程序运行在由RM（ResourceManager）启动的AP（APPMaster）适用于生产环境。 Mesos模式：Spark客户端直接连接Mesos；不需要额外构建Spark集群。国内应用比较少，更多的是运用yarn调度。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
</search>
