<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode刷题(每日)]]></title>
    <url>%2F2020%2F03%2F21%2Fleetcode%2F</url>
    <content type="text"><![CDATA[3.19日：数组中重复的数字在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 输入：[2,3,1,0,2,5,3]——&gt;输出：2或3 123456789#时间复杂度O(nlogn),空间复杂度O(1)class Solution(object): def findRepeatNumber(self,nums): nums.sort()#排序 previous = nums[0] for index in range(1,len(nums)): if previous == nums[index]: return previous previous = nums[index] 12345678910class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int[] arr = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123; arr[nums[i]]++; if(arr[nums[i]] &gt; 1) return nums[i]; &#125; return -1; &#125;&#125; 3.20日：最小的k个数输入整数数组 arr，找出其中最小的 k个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 例如：输入：arr=[3,2,1]，k=2——&gt;输出：[1,2]或者[2,1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def getLeastNumbers(self, arr, k): """ :type arr: List[int] :type k: int :rtype: List[int] """ a = [] arr.sort() for i in range(k): a.append(arr[i]) return a#官方答案class Solution(object): def getLeastNumbers(self, arr, k): """ :type arr: List[int] :type k: int :rtype: List[int] """ arr.sort() return arr[:k]#------------------------------------------------------class Solution(object): def getLeastNumbers(self, arr, k): """ :type arr: List[int] :type k: int :rtype: List[int] """ def partition(arr, left, right): key = arr[left] while left &lt; right: while left &lt; right and arr[right] &gt;= key: right -= 1 arr[left] = arr[right] while left &lt; right and arr[left] &lt;= key: left += 1 arr[right] = arr[left] arr[left] = key return left if len(arr) == 0 or k &lt;= 0: return [] if len(arr) &lt;= k: return arr low = 0 high = len(arr)-1 while low &lt; high: index = partition(arr, low, high) if k &lt; index: high = index-1 elif k &gt; index: low = index+1 elif k == index: break return arr[:k] 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; //利用快排思想，每次只处理一个部分 //补充：实际下标为k-1，但获取前k+1个也就获取了k个，-1操作反而消耗额外时间 //实际结果，将k换为k-1，时间消耗从2ms上升至3ms //具体思路： //当快排后的枢纽位置在k，恰好左边部分为要求的k+1个数 //当枢纽位置小于k，前几个数字已经确定，需要确定后几个数字，令low = pivot + 1继续 //当枢纽位置大于k，前k个数字在枢纽前，在枢纽前寻找数字，令high = pivot - 1继续 //下面讨论low &lt; high作为循环结束条件的合理性： //一般情况下，若k小于数组长度，low必然&lt;=k，high必然&gt;=k //由于pivot == k时直接结束循环不考虑，因此只有可能出现low == high == k //要使得上式成立，必然有两个状态满足pivot1==k-1和pivot2==k+1 //pivot1前的部分必然是小于k的，而pivot2后的部分必然是大于k的 //因此可以确定k是pivot1后数字中最小的一个，可以确定前k+1个数字已满足要求 //特殊情况下，k等于数组长度。此时pivot &lt; k始终成立，也就是pivot!=k //每趟处理后，必然有low = pivot + 1，也就是low必然会移动到满足low&gt;=high //由于k等于数组长度，因此无论如何变动，取出的数组一定满足要求 private int partition(int[] nums,int low,int high)&#123; int pivot = nums[low]; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; nums[high] &gt;= pivot) --high; nums[low] = nums[high]; while(low &lt; high &amp;&amp; nums[low] &lt;= pivot)&#123; ++low; nums[high] = nums[low]; &#125; nums[high] = nums[low]; &#125; nums[low] = pivot; return low; &#125; public int[] getLeastNumbers(int[] arr, int k) &#123; int low = 0; int high = arr.length - 1; while(low &lt; high)&#123; int pivot = partition(arr,low,high); if(pivot &gt; k) high = pivot - 1; if(pivot &lt; k) low = pivot + 1; if(pivot == k) break; &#125; return Arrays.copyOf(arr,k); &#125;&#125;]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ryu-manager执行问题]]></title>
    <url>%2F2020%2F02%2F07%2Fryu-manager%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述1：Ryu-manager执行自己编写的py程序后出现No module named XXX.py 注意：报错信息为没有自己定义的app模块 步骤1：先用python XXX.py执行一下，再ryu-manager XXX.py –verbose应该就可以了 步骤2：对于图片展示的错误，再确定没有语法错误的情况下，可能在对应的/usr/local/lib/python27/dist-packages/ryu/lib目录下没有跟ryu的编译安装目录下lib文件夹文件同步导致上述问题。例：在ryu/ryu/app下有一个Hub.py文件，可以通过scp命令复制到/usr/local/lib/python27/dist-packages/ryu/lib下。命令如下：scp -r &lt;源文件所在目录&gt; /usr/local/lib/python27/dist-packages/ryu/lib即可！ 问题描述2：SyntaxError: Non-ASCII character ‘\xe2’ 在python执行时出现该问题是因为文件格式编码出现了问题，具体原因和解决方法如下： 原因分析“SyntaxError: Non-ASCII character ‘\xe2’ in file”翻译为中文的意思是：在文件中存在着非法的ASCII字符 ASCII是8位即为一个字符，一共有256个字符，随着计算机的快速发展，现在已经发展到使用2个或者4个字符 出现该问题最常见于代码中出现中文字样，由于中文与英文编码上的差别而导致了错误。 解决方法：可以在文件头追加：– coding: cp936 – 或者 # -*- coding: utf-8]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Ryu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法]]></title>
    <url>%2F2020%2F01%2F29%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遗传算法1.简要概述 在几十亿年的演化过程中，自然界中的生物体已经 形成了一种优化自身结构的内在机制，它们能够不 断地从环境中学习，以适应不断变化的环境。对于大多数生物体，这个过程是通过自然选择和有性生殖来完成的。自然选择决定了群体中哪些个体 能够存活并繁殖，有性生殖保证了后代基因的混合 与重组。 演化计算（Evolutionary Computation, EC）是在达尔文（Darwin）的进化论和孟德 尔（Mendel）的遗传变异理论的基础上产生的一种在基因和种群层次上模拟自然界生 物进化过程与机制，进行问题求解的自组织、自适应的随机搜索技术。它以达尔文进化论的“物竟天择、适者生存”作为算法的进化规则，并结合孟德尔的遗 传变异理论，将生物进化过程中的繁殖（Reproduction）、变异（Mutation）、竞争 （Competition）、选择（Selection）引入到了算法中，是一种对人类智能的演化模拟方法演化计算的主要有遗传算法、演化策略、演化规划和遗传规划四大分支。其中，遗传算 法是演化计算中最初形成的一种具有普遍影响的模拟演化优化算法。 遗传算法简称GA（Genetic Algorithms）是1962年由美国Michigan大学的Holland教授提出的模拟自然界遗传机制和生物进化论而成的一种并行随机搜索最优化方法。遗传算法是以达尔文的自然选择学说为基础发展起来的。 自然选择学说包括以下三个方面： 遗传：这是生物的普遍特征，亲代把生物信息交给子代，子代总是和亲代具有相同或相似的性状。生物有了这个特征，物种才能稳定存在。 变异：亲代和子代之间以及子代的不同个体之间的差异，称为变异。变异是随机发生的，变异的选择和积累是生命多样性的根源。 生存斗争和适者生存：具有适应性变异的个体被保留下来，不具有适应性变异的个体被淘汰，通过一代代的生存环境的选择作用，性状逐渐与祖先有所不同，演变为新的物种。 2.基本原理遗传算法将“优胜劣汰，适者生存”的生物进化原理引入优化参数形成的编码串联群体中，按所选择的适应度函数并通过遗传中的复制、交叉及变异对个体进行筛选，使适应度高的个体被保留下来，组成新的群体新的群体既继承了上一代的信息，又优于上一代这样周而复始，群体中个体适应度不断提高，直到满足一定的条件遗传算法的算法简单，可并行处理，并能得到全局最优解。 3.基本操作遗传算法的基本操作有三种： 复制（Reproduction Operator） 从一个旧种群中选择生命力强的个体产生新种群的过程 具有高适应度的个体更有可能在下一代中产生一个或多个子孙 模拟无性繁殖 交叉（Crossover Operator） 复制操作能从旧种群中选择出优秀者，但不能创造新的染色体 交叉模拟了生物进化过程中的有性繁殖现象，通过染色体的交换组合，产生新的优良品种 交叉的过程：在匹配池中任选两个染色体，随机选择一点或多点交换点位置；交换双亲染色体交换点右边的部分，即可得到两个新的染色体数字串 变异(Mutation Operator) 模拟生物在自然的遗传环境中由于各种偶然因素引起的基因突变 以很小的概率随机地改变遗传基因（表示染色体的符号串的某一位）的值 在染色体以二进制编码的系统中，它随机地将染色体的某一个基因由1变为0，或由0变为1 变异的重要作用：没有变异，则无法在初始基因组合以外的空间进行搜索；使进化过程在早期就陷入局部解而进入终止过程；为了在尽可能大的空间中获得质量较高的优化解（水至清则无鱼） 4.应用领域 函数优化：非线性、多模型、多目标的函数优化问题，采用其他优化方法较难求解，而遗传算法却可以得到较好的结果 组合优化：随着问题的增大，组合优化问题的搜索空间也急剧扩大，采用传统的优化方法很难得到最优解 自动控制：利用遗传算法进行控制器参数的优化；基于遗传算法的模糊控制规则的学习；基于遗传算法的参数辨识；基于遗传算法的神经网络结构的优化和权值学习 机器人：移动机器人路径规划、关节机器人运动轨迹规划、机器人结构优化和行为协调 图像处理：图像处理过程中的扫描、特征提取、图像分割等的优化计算；模式识别、图像恢复、图像边缘特征提取 5.关键概念（1）编码 研究生物遗传是从染色体入手的 染色体是由基因排成的串，可以理解为生物编码 研究遗传算法，研究如何编码是第一步工作 编码是通过某种机制把求解问题抽象为由特定符号按一定顺序 排成的串 使用二进制串进行编码是常见的方法 利用遗传算法求下列一元函数的最大值，其中x∈[-1,1]，求解结果精确到6位小数，请问如何编码？ f(x)=x*sin(8πx)+3.0 【解】由于区间长度为2，求解结果精确到6位小数，因此可以将自变量定义区间划分为等份。又因为2^20 &lt; 2*10^6 &lt; 2^21，所以本例的二进 制编码长度至少需要21位，本例的编码过程实质上是将区间[-1,1]内对 应的实数值转化为一个二进制串（ ） （2）初始种群确定编码方案后，遗传算法通常采用随机方法生成若干个个体的集合，该集合称为初始种群，初始种群中个体的数量称为种群规模。 （3）适应度函数遗传算法对一个个体（解）的好坏用适应度函数值来评价 适应度函数值越大，解的质量越好 适应度函数是遗传算法进化过程的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定 遗传算法使用选择运算来实现对群体中的个体进行优胜劣汰操作：适应度高的个体被遗传到下一代群体中的概率大；适应度低的个体，被遗传到下一代群体中的概率小 （4）遗传算子 选择操作的任务就是按某种方法从父代群体中选取一些个体，遗传到下一代群体 选择算子采用轮盘赌选择方法，又称比例选择算子，它的基本思想是： 各个个体被选中的概率与其适应度函数值大小成正比。设群体大小为n ，个体i 的适应度为 Fi ，则个体i 被选中遗传到下一代群体的概率为： 轮盘赌选择方法的实现步骤如下：①计算群体中所有个体的适应度函数值（需要解码）②利用比例选择算子的公式，计算每个个体被选中遗传到下一代群体的概率③采用模拟赌盘操作（即生成0到1之间的随机数与每个个体遗传到下一代群体的概率进行匹配）来确定各个个体是否遗传到下一代群体中 （5）交叉运算交叉运算是指对两个相互配对的染色体依据交叉概率 Pc 按某种方式相互交换其部分基因，从而形成两个新的个体。交叉运算是遗传算法区别于其他进化算法的重要特征，它在遗传算法中起关键作用，是产生新个体的主要方法。交叉算子一般采用单点交叉算子： 交叉前(用”|”来表示交叉点)： 00000|01110000000010000 11100|00000111111000101 交叉后： 00000|00000111111000101 11100|01110000000010000 （6）变异运算所谓变异运算，是指依据变异概率 Pm 将个体编码串中的某些基因值用其它基因值来替换，从而形成一个新的个体。 遗传算法中的变异运算是产生新个体的辅助方法，它决定了遗传算法的局部搜索能力，同时保持种群的多样性，交叉运算和变异运算的相互配合，共同完成对搜索空间的全局搜索和局部搜索，变异算子采用基本位变异算子。基本位变异算子是指对个体编码串随机指定的某一位或某几位基 因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0 变异前： 000001110000000010000 变异后： 000001110001000010000 6.遗传算法应用实例①函数最值问题利用遗传算法求函数最值（极值）问题是清晰地理解遗传算法的一个较好的途径 【例】求函数f(x1,x2)=x1^2+x2^2的最大值，其中x1 及x2取值范围为{1,2,3,4,5,6,7} ②编码本例用无符号二进制整数来表示，因 x1, x2 为 0 ~ 7之间的整数，分别用3位无符号二进制整数来表示 将它们连接在一起所组成的6位无符号二进制数就形成了个体的基因型，表示一个可行解 如：基因型X＝101110所对应的表现型是：x＝[ 5，6 ]。个体的表现型x和基因型X之间可通过编码和解码程序相互转换 ③初始群体的产生遗传算法是对群体进行的进化操作，需要给其准备一些表示起始搜索点的初始群体数据 本例中，群体规模的大小取为4，即群体由4个个体组成，每个个体可通过随机方法产生 如：011101，101011，011100，111001 ④适应度计算遗传算法以个体适应度的大小来评定各个个体的优劣程度，从 而决定其遗传机会的大小 本例中，目标函数总取非负值，并且是以求函数最大值为优化目标，故可直接利用目标函数值作为个体的适应度 ⑤选择运算选择运算(或称为复制运算)把当前群体中适应度较高的个体按某种规则或模型遗传到下一代群体中，一般要求适应度较高的个体将有更多的机会遗传到下一代群体中 采用与适应度成正比的概率来确定各个个体复制到下一代群体中的数量。其具体操作过程是： 先计算出群体中所有个体的适应度的总和 Σfi ( i=1.2,…,M ); 其次计算出每个个体的相对适应度的大小 fi / Σfi，它即为每个个体被遗传到下一代群体中的概率 每个概率值组成一个区域，全部概率值之和为1 最后再产生一个0到1之间的随机数，依据该随机数出现在上述哪一个概率区域内来确定各个个体被选中的次数 ⑥交叉运算交叉运算是遗传算法中产生新个体的主要操作过程，它以某一概率相互交换某两个个体之间的部分染色体。本例采用单点交叉的方法，其具体操作过程是：先对群体进行随机配对，其次随机设置交叉点位置；最后再相互交换配对染色体之间的部分基因 其中新产生的个体“111101”、“111011”的适应度较原来两个个体的适应度都要高 ⑦变异运算变异运算是对个体的某一个或某一些基因座上的基因值按某一较小的概率进行改变，它也是产生新个体的一种操作方法。本例中，我们采用基本位变异的方法来进行变异运算，其具体操作过程是：首先确定出各个个体的基因变异位置，下表所示为随机产生的变异点位置，其中的数字表示变异点设置在该基因座处；然后依照某一概率将变异点的原有基因值取反 ⑧新一代对群体P(t)进行一轮选择、交叉、变异运算之后可得到新一代的群体p(t+1) 群体经过一代进化之后，其适应度的最大值、平均值都得到了明显的改进。事实上，这里已经找到了最佳个体“111111” https://zhuanlan.zhihu.com/p/93749379]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mininet+Ryu]]></title>
    <url>%2F2020%2F01%2F19%2FMininet-Ryu%2F</url>
    <content type="text"><![CDATA[MininetMininet是什么？ Mininet可以做什么？ Mininet文件结构 常用目录：custom/ util/ examples/ Mininet常用命令图谱 网络构建参数topo depth:交换机的深度（如图，交换机有两层，主机这一层是不包含在depth里的） fanout:数值为2，代表s1的交换机下下挂2个交换机（广度） switch controller mac sudo mn --topo=tree,depth=2,fanout=2,--mac 内部交互命令 添加一个主机 py net.addHost(‘h3’) 添加链路 py net.addLink(s1,net.get(‘h3’)) 添加一个端口 py.attach(‘s1-eth3’) 添加新增主机的ip py net.get(‘h3’).cmd(‘ifconfig h3-eth0 10.0.0.3’) Mininet可视化 启动Miniedit 查看流表 添加流表 删除流表 添加丢弃数据包的流表 代码：mn –custom xxx.py –topo xxx –controller=remote,ip=127.0.0.1,port=6653 问题：dpctl add-flow in_port=1,actions=drop执行了之后，为什么pingall还是可以？因为在执行之后，控制器下发的流表还存在，且优先权大于自己定义的流表，可以先dpctl del-flows之后再执行。 模拟多数据中心带宽实验Mininet数据中心应用价值 流量模拟介绍 数据中心拓扑逻辑网络 流量随机模型在Mininet中的应用 Mininet自定义命令拓展实现 首先在mininet/net.py中定义iperf_single()函数，在两个主机之间进行iperf udp测试，并且在server端记录，实现iperf_single函数 在net.py中添加自定义命令iperfmulti()函数，依次为每一台主机随机选择另一台主机作为iperf的服务器端，通过调用iperf_single，自身以客户端按照指定参数发送UDP流 mininet/cli.py中注册iperfmulti命令，解析用户输入的命令，net.py定义的iperfmulti命令需要在CLI类中注册 在bin/mn中加入iperfmulti可执行命令，将iperfmulti加入到对应的列表中 重新编译mininet 进入mininet/util目录，重新编译安装mininet 重新创建网络，如mn，输入iperf，可用table补全iperfutil，从而可使用iperfmulti进行流量随机模型的测试 RyuRyu是什么？ Ryu是一个轻量级的，开源的SDN控制器 Ryu架构 基于跳数的最短路径转发原理]]></content>
      <categories>
        <category>Mininet</category>
      </categories>
      <tags>
        <tag>Mininet</tag>
        <tag>Ryu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ceph组件]]></title>
    <url>%2F2019%2F12%2F15%2FCeph%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Ceph组件RADOS（Reliable Autonomic Distributed Object Store）RADOS是Ceph 存储集群的基础。Ceph 中的一切都以对象的形式存储，而RADOS 就负责存储这些对象，而不考虑它们的数据类型。RADOS 层确保数据一致性和可靠性。对于数据一致性，它执行数据复制、故障检测和恢复。还包括数据在集群节点间的recovery。 OSD实际存储数据的进程。通常一个OSD daemon绑定一个物理磁盘。Client write/read 数据最终都会走到OSD去执行write/read操作。 MON（monitor）Monitor在Ceph集群中扮演者管理者的角色，维护了整个集群的状态，是Ceph集群中最重要的组件。 Mon保证集群的相关组件在同一时刻能够达成一致，相当于集群的领导层，负责收集、更新和发布集群信息。为了规避单点故障，在实际的Ceph部署环境中会部署多个Mon，同样会引来多个Mon之前如何协同工作的问题。 LIbrados简化访问RADOS的一种方法，目前支持PHP、Ruby、Java、Python、C和C++语言。它提供了Ceph 存储集群的一个本地接口RADOS ，并且是其他服务(如RBD 、RGW) 的基础，以及为CephFS 提供POSIX 接口。librados API 支持直接访问RADOS ，使得开发者能够创建自己的接口来访问Ceph 集群存储。 RBDCeph块设备。对外提供块存储。可以像磁盘一样被映射、格式化已经挂载到服务器上。支持snapshot。 RGWCeph对象网关，提供了一个兼容S3和Swift的restful API接口。RGW还支持多租户和Openstack的keyston身份验证服务。 CephFS提供了一个任意大小且兼容POSlX的分布式文件系统。CephFS 依赖Ceph MDS 来跟踪文件层次结构，即元数据。 MDSCeph元数据服务器，跟踪文件层次结构并存储只供CephFS使用的元数据。Ceph块设备和RADOS网关不需要元数据。MDS不直接给client提供数据服务。 Ceph RADOSRADOS 是Ceph 存储系统的核心，也称为Ceph 存储集群。Ceph 的所有优秀特性都是由RADOS 提供的，包括分布式对象存储、高可用性、高可靠性、没有单点故障、向我修复以及自我管理等。RADOS 层在Ceph 存储架构中扮演着举足轻重的角色。Ceph 的数据访问方法(如RBD 、CephFS 、RADOS GW 和librados ) 的所有操作都是在RADOS 层之上构建的。 当Ceph 集群接收到来向客户端的写请求时，CRUSH 算法首先计算出存储位置，以此决定应该将数据写入什么地方。然后这些信息传递到队DOS 层进行进一步处理。基于CRUSH 规则集，RADOS 以小对象的形式将数据分发到集群内的所有节点。最后，将这些对象存储在OSD 中。 当配置的复制数大于1时，队DOS 负责数据的可靠性。同时，它复制对象，创建副本，并将它们存储在不同的故障区域中，换言之，同一个对象的副本不会存放在同一个故障区域中。然而，如果有更多个性化需求和更高的可靠性，就需要根据实际需求和基础架构来优化CRUSH 规则集。RADOS 能够保证在一个RADOS 集群中的对象副本总是不少于一个，只要你有足够的设备。 除了跨集群存储和复制对象之外，RADOS 也确保对象状态的一致性。在对象不一致的情况下，将会利用剩下的副本执行恢复操作。这个操作自动执行，对于用户而言是透明的，从而为Ceph 提供了自我管理和自我修复的能力。如果仔细分析Ceph 的架构图，你会发现它有两部分: RADOS 在最下部，它完全处于Ceph集群的内部，没有提供给客户端直接接口;另一部分就是在RADOS 之上的面向所有客户端的接口。 Ceph 对象存储设备Ceph 的OSD 是Ceph 存储集群中最重要的一个基础组件，它负责将实际的数据以对象的形式存储在每一个集群节点的物理磁盘驱动器中。Ceph 集群中的大部分工作是由OSD 守护进程完成的。存储用户数据是真正最耗时的部分。 Ceph OSD 以对象的形式存储所有客户端数据，并在客户端发起数据请求时提供相同的数据。Ceph 集群包含多个OSD 。对于任何读或写操作，客户端首先向monitor 请求集群的map ，然后，它们就可以无须monitor 的干预直接与OSD 进行I/O操作也正是因为产生数据的客户端能够直接写入存储数据的OSD 而没有任何额外的数据处理层，才使得数据事务处理速度如此之快。与其他存储解决方案相比，这种类型的数据存储和取回机制是Ceph 所独有的。 Ceph 的核心特性(比如可靠性、自平衡、自恢复和一致性)都始于OSD 。根据配置的副本数， Ceph通过跨集群节点复制每个对象多次来提供可靠性，同时使其具有高可用性容错性。OSD 上的每个对象都有一个主副本和几个辅副本，辅副本分散在其他OSD 上。由于Ceph 是一个分布式系统且对象分布在多个OSD 上，因此每一个OSD 对于一些对象而言是主副本。但同时对于其他对象而言就是辅副本，存放辅副本的OSD 受主副本OSD 控制;然而，它们也可能又成为主副本OSD 。 Ceph的OSD由一个已经存在Linux 文件系统的物理磁盘驱动器和10SD 服务组成。 Linux文件系统对于OSD 守护进程而言是相当重要的，因为它决定了支持哪些扩展属性( XATTR) 。这些文件系统扩展属性能够为OSD 守护进程提供内部对象的状态、快照、元数据和ACL 等信息.这有助于数据管理。 OSD在拥有有效Linux 分区的物理磁盘驱动器上进行操作。Linux 分区可以是Btrfs (B树文件系统)、XFS 或ext4。Ceph 集群的性能基准测试的主要标准之一就是文件系统的选择。 Btrfs 与使用XFS 和ext4 文件系统的OSD 相比，使用Btrfs 文件系统的OSD 能够提供更佳的性能。使用Btrfs 最主要的一个优点是支持写时复制和可写的快照，这对于虑拟机的部署和克隆非常有用。在文件系统中它还支持透明的压缩、普遍的校验和多设备的统一管理。还支持高效的XATTR 、对于小文件的合井，还有SSD上所熟知的集成卷管理，并支持在线fsck 的特性。然而，尽管有如此多的新特性，Btrfs 目前还不具备应用于生产系统的条件，但对于测试而言它是一个很好的选择。 XFS 这是一个可靠、成熟且非常稳定的文件系统，因此，我们推荐在生产环境的Ceph 集群中使用它。XFS 是Ceph存储中最常用的文件系统.也是推荐OSD 使用的文件系统。然而，从另一个方面来看，XFS 又不如Btrfs。XFS 在元数据扩展性上存在性能问题，XFS 也是一种日志文件系统， 也就是说.每次客户端发送数据以写入Ceph 集群时，肯先需要写人口志空间，然后再写入XFS 文件系统这样的两次写入操作增加了开销从而使得XFS 的性能不如Btrfs，Btrfs 没有使用日志。 Ext4 ext4 文件系统也是一种日志文件系统，是一个远合生产环境下Ceph OSD 使用的文件系统;然而，它的受欢迎程度不如XFS 。从性能的角度来看，ext4 文件系统也不如Btrfs。 Ceph OSD 使用诸如Btrfs 和XFS 的日志文件系统。在将数据提交到备用存储之前，Ceph 首先将数据写入一个称为日志( journal) 的独立存储区域，日志是相同的机械磁盘(如OSD) 或不同的SSD 磁盘或分区上一小块缓冲区大小的分区，甚至也可以是文件系统上的一个文件。在这种机制中，Ceph 的所有写都是先到日志，然后再到备用存储. Ceph Monitor顾名思义，Ceph monitor 负责监控整个集群的健康状况。它们以守护进程的形式存在，这些守护进程通过存储集群的关键信息来维护集群成员状态、对等节点状态，以及集群配置信息。Ceph monitor 通过维护整个集群状态的主副本来完成它的任务。集群map 包括monitor 、OSD 、PG 、CRUSH 和MDS map o 所有这些map 统称为集群map 。让我们简单地浏览一下每个map 的功能。 Monitor Map 它维护着monitor 节点间端到端的信息，其中包括Ceph 集群ID 、monitor 主机名、IP 地址及端口号。它还存储着当前map 的创建版本和最后一次修改的信息。可以通过下面的命令检查集群的monitor map: # ceph mon dump OSD Map 它存储着一些常见的信息，如集群ID、OSD map 创建版本和最后一次修改信息，以及与池相关的信息(如池名字、池ID 、类型、副本数和归置组) 。它还存储着OSD 的一些信息，如数目、状态、权重、最近处于clean 状态的间隔以及OSD 主机等信息。可以通过执行以下命令获取集群的OSD map: # ceph osd dump PG Map 它存储着归置组的版本、时间戳、最新的OSD map 版本、容量充满的比例以及容量接近充满的比例等信息。它同时也跟踪每个归置组的ID 、对象数、状态状态时间戳、OSD 的叩集合、OSD 的acting 集合，最后还有清洗等信息。要检查集群的PG map ，执行: # ceph pg dump CRUSH Map 它存储着集群的存储设备信息、故障域层次结构以及在故障域中定义如何存储数据的规则。要查看集群的CRUSH map ，执行: # ceph osd crush dump MDS Map 它存储着当前MDS map 的版本，map 的创建和修改时间，数据和元数据池的ID ，集群中MDS 的数目以及MDS 的状态。要查看集群MDS map ，执行: # ceph mds dump 一个典型的Ceph 集群通常包含多个monitor 节点。多monitor 的Ceph 架构使用了仲 裁( quorum ) ，使用Paxos 算法为集群提供了分布式决策机制。集群中monitor 数目应该是奇数，最低要求是一个monitor 节点，推荐的数是3 。自monitor开始仲裁操作，至少需要保证一半以上的monitor 始终处于可用状态，这样才可以防止其他系统可以看到的脑裂问题。 这就是为什么推荐使用奇数个monitor。在所有的集群monitor 巾，其中有一个是领导者( leader ) 。如果领导者monitor不可用其他monitor 节点也有权成为领导者。生产环境下的集群必须至少有三个monitor节点来提供高可用性。 对于企业级生产环境，建议使用专门的monitor 节点。这样， 一旦你的OSD 节点发生 故障，只要你有足够的monitor 运行在独立的机器上，你仍然可以连接到你的Ceph 集群。在存储的规划阶段，也应该考虑物理机架的布局。你应该将monitor节点分散到所有的故障域中，例如，不同的开关、电源和物理机架。如果你有多个数据中心连接在同一个高速网络，monitor 节点应该放到不同的数据中心。 Ceph块存储块存储是企业环境中最常见的一种数据存储格式。Ceph 块设备也称为RADOS 块设备(RBD) ;它为物理层的虚拟机监控程序以及虚拟机提供块存储解决方案。Ceph 的RBD 驱动程序已经被集成到Linux 内核( 2.6.39 或更高版本)中，而且已经被QEMU/KVM 支持，它们能无缝地访问Ceph 块设备。 Linux主机能全力支持内核RBD (KRB D ) 并通过librados 映射Ceph 块设备。然后RADOS将Ceph 块设备的对象以分布式模式存储在集群中。一旦Ceph 块设备映射到Linux主机，它也可以当作裸分区或标记为文件系统，然后进行挂载。 Ceph对象网关Ceph 对象网关，也称做RADOS 网关，它是一个代理，可以将HTTP 请求转换为RADOS ，同时也可以把RADOS 请求转换为HTTP 请求，从而提供RESTful 对象存储，这兼容S3 和Swift。Ceph 对象存储使用Ceph 对象网关守护进程( radosgw) 与librgw 、librados (Ceph 集群)交互。这是使用libfcgi 作为FastCGI的一个模块来实现的，并且可以被任何支持FastCGl的Web 服务器使用。 Ceph文件系统CephFS 在RADOS 层之上提供了一个兼容POSIX 的文件系统。它使用MDS 作为守护进程，负责管理其元数据并将它和其他数据分开，这有助于降低复杂性并提高可靠性。CephFS 继承了RADOS 的特性并为数据提供了动态再平衡。]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea项目运行时报错提示Could not locate executable null\bin\winutils.exe in the Hadoop binaries]]></title>
    <url>%2F2019%2F10%2F13%2Fidea%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Chadoop%2F</url>
    <content type="text"><![CDATA[首先需要在你的java项目中添加配置语句：System.setProperty(“hadoop.home.dir”,”hadoop解压后的路径”)(前提是已经把解压好的winutils.exe放入解压路径下bin目录下) 配置hadoop的环境变量(HADOOP_HOME及在PATH中添加HADOOP_HOME) 附：hadoop2.7.X的winutils.exe链接 winutils.exe]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink(基础)]]></title>
    <url>%2F2019%2F10%2F12%2FFlink%2F</url>
    <content type="text"><![CDATA[FlinkSpark分实时部分和离线部分，Flink还是替代不了离线部分，Spark和Hive可以无缝整合，Flink暂时还达不到，还没有官方的支持，实时部分和Spark平起平坐 特点：事件驱动型以事件为单位的计算，一件事一件事的处理，kafka的通道里的单元，flume的channel里的event也是，SparkStreaming是微批次，数据进入spark的时候会定义一个批次的时间，是以时间为单位而不是以事件为单位的，区别：对数据更加敏感。会减少数据的延迟性。 流和批的世界观批处理的特点是有界、持久、大量，非常适合需要访问全套记录才能完成的计算工作，一般用于离线统计。 流处理的特点是无界、实时, 无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。 分层Api spark也分层，比如RDD操作这是一层，还有一层SQL，本质来说都是RDD的，转义到SQL DataStream 实时的，DataSet 离线的，处于中间层，灵活。类似于map，filter，reduceByKey等等，和Spark的算子很像。 高级层有SQL和Table Api，TableApi像.select().where().groupBy()，好处是代码简介，利于读懂，偏向业务逻辑 低级层 有状态计算spark也有有状态计算，类似于updatastatebykey，把状态存在checkpoint里。 flink也有状态的维护，一般存在redis里，也可以存在checkpoint里。但是说到底checkpoint只是个机制，检查点机制，checkpoint存在哪儿是可以选择的，可以放在磁盘和内存中和HDFS中 Flink state两种 operator state:操作状态，整个的数据流在每一个算子中计算，计算完成还是没完成会把这个状态存起来，为了后续的提交操作。相当于存的执行的情况 Keyed state:以key为单位，存的值就是state。相当于存的业务的数据 无状态计算会观察每个独立的事件，并且会在最后一个时间出结果，例如一些报警和监控，一直观察每个事件，当触发警报的事件来临就会触发警告。 有状态的计算就会基于多个事件来输出结果，比如说计算过去一个小时的平均温度等等。 支持Exactly-once语义希望有且只执行一次，数据处理最佳的状态 At Most once:最多一条或者没有，这种情况会造成数据丢失 At Least once:最少一次，一旦我觉得发送失败了，就再发送一次，可是我觉得发送失败了，不一定就真的发送失败了，有误判，会造成数据的重复 Exactly-once:如果我发送成功了，不会再发，如果没成功，一定会再发 spark官方达不到Exactly-once的状态 spark可以人为的操作来实现Exactly-once状态。数据一进来就提交，中间处理失败了，kafka不会认为处理失败了，这件事已经过去了，已经处理成功了，可以在末尾提交，需要人为的把提交的操作摞到某一个业务点，确认处理完成后提交，即调整kafka的偏移量offset，如偏移量放在zookeeper，需要自己去调整zookeeper Flink自己帮你完成了，每个操作都有自己的状态 支持事件事件（Eventtime）目前大多数框架时间窗口计算，都是采用当前系统时间，以时间为单位进行的聚合计算只能反应数据到达计算引擎的时间，而并不是实际业务时间 例如，spark的开窗函数，开一个window，取最近一小时，指数据流到spark的一小时，不管数据是什么时候产生的不关心，只以数据进入spark为准]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10更新到1903后,出现Vmware workstation pro无法打开]]></title>
    <url>%2F2019%2F10%2F04%2FVmware%2F</url>
    <content type="text"><![CDATA[时间：2019年10月份 在这个更新后，我的vmware workstation pro无法打开，提示需要安装最新版本，然而又不能打开检查更新，只能卸载再安装了15.5的版本。 问题：安装了之后无法ping和上网说明：之前配过3台的虚拟机集群，所以安装完之后直接打开，可以通过ifconfig显示ip，各个虚拟机之间可以ping，而且ssh也可以。但是每个都无法ping主机和www.baidu.com。第一步：切换为root权限，查看/etc/sysconfig/network-scripts/ifcfg-enoXXXX，看看是否有误! 第二步：查看服务，关于vmware的服务是否都已经启动第三步：打开windows的网络连接，查看 第四步：打开vmware的编辑，打开虚拟机网络编辑器，查看VMnet8的子网地址的前三位是否和自己配置的静态ip的前三位相等，若是不相同，把Vmnet8的子网地址前三位改为和虚拟机ip前三位相同即可。 第五步：查看网络适配器 测试：ping主机和baidu.com 成功！]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop+hbase启动出现的问题]]></title>
    <url>%2F2019%2F09%2F18%2Fhadoop-hbase%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.集群描述：三台虚拟机搭建 hadoop101 hadoop102 hadoop103 Datanode Datanode Datanode Namenode QuorumPeerMain QuorumPeerMain QuorumPeerMain NodeManager NodeManager NodeManager ResourceManager SecondaryNameNode HRegionServer HRegionServer HRegionServer HMaster Jps Jps Jps 2.问题的过程首先，Hadoop101作为三台虚拟机中的最重要的，平时安装时都十分小心，Hadoop102和Hadoop103由于有一次VMware关机时卡死，直接通过ctrl+shift+delete强制结束进程，导致Hadoop102的文件损坏，于是我克隆了Hadoop103，再把ip等一些配置重新配置了一下（最主要的是zookeeper的data/zkData/myid（这个位置是自己定义的dataDir的地址），以及kafka的conf/server.properties里的broker.id=#，每个虚拟机都不相同）。在我运行如下的shell脚本，一键启动后 1234567891011121314151617181920212223242526272829303132333435#!/bin/bashecho "=================正在开启集群服务==================="echo "================正在开启zookeeper服务=================="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh start'doneecho "=============正在开启NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start namenode'echo "=============正在开启DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start datanode'doneecho "=============正在开启SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start secondarynamenode'echo "==========正在开启ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start resourcemanager'echo "==============正在开启NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start nodemanager'done# echo "============正在开启JobHistoryServer============"# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh start historyserver'echo "============正在开启Hbase节点============"ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/start-hbase.sh' 出现了两个问题： HMaster出现一会儿就消失，其他都正常 HMaster正常，Hadoop102或者Hadoop103的DataNode其中一个过会儿会消失 摸索了一个下午，终于解决了，只是不清楚为什么会好了，以下是我改的部分。 1.我改了hbase安装目录下的conf/hbase-env.sh的export HBASE_MANAGES_ZK=false，将其开头的#去除2.我发现hbase安装目录下的conf/hbase-site.xml的zookeeper的dataDir地址填错了1234&lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/modules/zookeeper-3.4.10/data/zkData&lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群启动脚本全]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%9B%86%E7%BE%A4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[大数据集群启动脚本1234567891011121314151617181920212223242526272829303132333435#!/bin/bashecho "=============正在开启集群服务================="echo "===============正在开启zookeeper服务================"for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh start'doneecho "=============正在开启NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start namenode'echo "=============正在开启DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start datanode'doneecho "=============正在开启SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start secondarynamenode'echo "==========正在开启ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start resourcemanager'echo "==============正在开启NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start nodemanager'done# echo "============正在开启JobHistoryServer============"# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh start historyserver'echo "============正在开启Hbase节点============"ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/start-hbase.sh' 关闭脚本12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashecho "=============正在关闭集群服务================="echo "=============正在关闭HBase节点============="ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/stop-hbase.sh'# echo "=============正在关闭JobHistoryServer节点============="# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh stop historyserver'echo "==========正在关闭ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh stop resourcemanager'echo "==============正在关闭NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh stop nodemanager'doneecho "=============正在关闭NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop namenode'echo "=============正在关闭SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop secondarynamenode'echo "=============正在关闭DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop datanode'doneecho "===============正在关闭zookeeper服务================"for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh stop'done 查询启动服务脚本12345678#!/bin/sh#查看各个主机的java进程for HOST in hadoop101 hadoop102 hadoop103do echo ===================== $HOST ======================= ssh $HOST "jps"done]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装及问题"net/http:TLS handshake timeout"]]></title>
    <url>%2F2019%2F09%2F01%2FDocker%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[一、安装Docker步骤： 123456789101112131415161718192021//******需要root权限******//1.检查内核版本，必须是3.10及以上使用命令 uname -r2.安装dockeryum install docker3.安装过程中需要确认，输入y即可4.启动dockersystemctl start docker查看版本docker -vDocker version 1.13.1, build 7f2769b/1.13.15.设置开机启动dockersystemctl enable dockerCreated symlink from /etc/systemd/system/multi‐user.target.wants/docker.service to/usr/lib/systemd/system/docker.service. 6.停止dockersystemctl stop docker 二、Docker常见命令及操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 例：docker search redis 去docker hub检索镜像的详细信息，如镜像的Tag 拉取 docker pull 镜像名:tag 例：docker pull redis 其中:tag是可选的，tag表示标签，是软件的版本，不设置默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（类似于lol客户端）—–运行镜像—-产生了一个容器（lol正在运行） 步骤： 12345678910111213141516171819202122232425262728291、搜索镜像docker search tomcat2、拉取镜像docker pull tomcat3、根据镜像启动容器docker run ‐‐name mytomcat ‐d tomcat:latest4、查看运行中的容器docker ps5.停止运行中的容器docker stop id6.查看所有的容器docker ps -a7.启动容器docker start id8.删除一个容器docker rm id9.启动一个有端口映射的tomcatdocker run -d -p 8888:8080 mytomcat//-d：后台运行//-p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口10.关闭linux的防火墙service firewall status //查看防火墙的状态service firewall stop //关闭防火墙11.查看容器的日志docker logs id/***更多命令参考文档https://docs.docker.com/engine/reference/commandline/docker/*/ 注意点： 当docker search 关键字后，准备docker pull 关键字时，命令行会出现“net/http: TLS handshake timeout”，这是由于docker默认镜像拉取地址为国外仓库，下载速度慢，我们只需要将拉取地址修改为国内镜像仓库即可（可使用阿里云提供的加速服务） 阿里云容器镜像服务 首先会让你登录账号，一步步来，之后左侧栏底部有镜像加速器，点进去可以看到类似于https://xxxxxx.mirror.aliyuncs.com的加速器地址，xxxxx每个人的都不一样，将它先复制，打开安装docker的虚拟机或者主机。 123456789//1.输入命令vi /etc/docker/daemon.json//2.按照如下修改&#123; "registry-mirrors": ["https://xxxxxx.mirror.aliyuncs.com"]&#125;//3.重启docker服务 docker删除镜像文件时，出现image is referenced in multiple repositories如何解决? ​ 我们可以发现这两个都是redis，只是版本号不同，IMAGE ID两个都一样，因此无法删除。 ​ 但是可以用repository和tag的方式来删除 121.docker rmi docker.io/redis //先根据repository删除一个2.docker rmi f7302e4ab3a8 //再用id删除一个]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA导入项目报错non-managed pom.xml file found]]></title>
    <url>%2F2019%2F08%2F16%2FIDEA-bug%2F</url>
    <content type="text"><![CDATA[第一步：点击右侧的maven视图 第二步：选择需要添加的pox.xml文件 第三步：选择项目运行需要的SDK OVER]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD认知(下)]]></title>
    <url>%2F2019%2F08%2F12%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[一、转换操作(续) 函数 解释 示例 def aggregateByKey[U:ClassTag](zeroValue:U,partitioner:Partitioner)(seqOp:(U,V)=&gt;U,combOp:(U,U)=&gt;U):RDD[(K,U)] 通过seqOp函数将每一个分区里面的数据和初始值迭代带入函数返回最终值，comOp将每一个分区返回的最终值根据key进行合并操作 略 def foldByKey(zeroValue:V,partitioner:Partitioner)(func:(V,V)=&gt;V):RDD[(K,V)] aggregateByKey的简化操作，seqop和combop相同 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)val agg = rdd.foldByKey(0)(+).collect def sortByKey(ascending:Boolean=true,numPartitions:Int=self.partitions.length):RDD[(K,V)] 在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD val rdd = sc.parallelize(Array((3,”aa”),(6,”cc”),(2,”bb”),(1,”dd”))) rdd.sortByKey(true).collect() def sortBy[K](f:(T)=&gt;K,ascending:Boolean=true,numPartitions:Int = this.partitions.length)(implicit ord:Ordering[K],ctag:ClassTag[K]):RDD[T] 底层实现还是使用sortByKey，只不过使用fun生成的新key进行排序 val rdd = sc.parallelize(List(1,2,3,4)) rdd.sortBy(x =&gt; x%3).collect() def join[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(V,W))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD val rdd1= sc.parallelize(Array((1,”a”),(2,”b”),(3,”c”)))) val rdd2 = sc.parallelize(Array((1,4),(2,5),(3,6))) rdd1.join(rdd2).collect() def cogroup[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(Iterable[V], Iterable[W]))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable,Iterable))类型的RDD 略 def cartesian[U:ClassTag](other:RDD[U]):RDD[(T,U)] 笛卡尔积 val rdd1 = sc.parallelize(1 to 3) val rdd2 = sc.parallelize(2 to 5) rdd1.cartesian(rdd2).collect() def pipe(command:String):RDD[String] 对于每个分区，都执行一个perl或者shell脚本，返回输出的RDD 略 def coalesce(numPartitions:Int,shuffle:Boolean=false,partitionCoalescer: Option[PartitionCoalescer]=Option.empty)(implicit ord:Ordering[T]=null):RDD[T] 缩减分区数，用于大数据集过滤后，提高小数据集的执行效率 略 def repartition(numPartitions:Int)(implicit ord:Ordering[T]=null):RDD[T] 根据分区数,重新通过网络随机洗牌所有数据 略 def repartitionAndSortWithinPartitions(partitioner:Partitioner):RDD[(K,V)] repartitionAndSortWithinPartitions函数是repartition函数的变种，与repartition函数不同的是，repartitionAndSortWithinPartitions在给定的partitioner内部进行排序，性能比repartition要高 略 def glom():RDD[Array[T]] 将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]] val rdd = sc.parallelize(1 to 16,4) rdd.glom().collect() def mapValues[U](f:V=&gt;U):RDD[(K,U)] 针对于(K,V)形式的类型只对V进行操作 val rdd3 = sc.parallelize(Array((1,”a”),(1,”d”),(2,”b”),(3,”c”))) rdd3.mapValues(_+”|||”).collect() def subtract(other:RDD[T]):RDD[T] 计算差的一种函数去除两个RDD中相同的元素，不同的RDD将保留下来 val rdd = sc.parallelize(3 to 8) val rdd1 = sc.parallelize(1 to 5) rdd.subtract(rdd1).collect() 二、行动操作 函数 解释 示例 def takeSample(withReplacement:Boolean,num:Int,seed:Long=Utils.random.nextLong):Array[T] 返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子 val rdd=sc.parallelize(1 to 10,2)rdd.takeSample(true,5,3) def reduce(f:(T,T)=&gt;T):T 通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的 val rdd1 = sc.makeRDD(1 to 10,2) rdd1.reduce(+) def collect():Array[T] 在驱动程序中，以数组的形式返回数据集的所有元素 太常用，略 def count():Long 返回RDD的元素个数 略 def first():T 返回RDD的第一个元素（类似于take(1)) 略 def take(num:Int):Array[T] 返回一个由数据集的前n个元素组成的数组 略 def takeOrdered(num:Int)(implicit ord:Ordering[T]) 返回前几个的排序 略 def aggregate[U:ClassTag](zeroValue:U)(seqOp:(U,T)=&gt;U,combOp:(U,U)=&gt;U):U aggregate函数将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。这个函数最终返回的类型不需要和RDD中元素类型一致 scala&gt; var rdd1 = sc.makeRDD(1 to 10,2) scala&gt;rdd1.aggregate(1){(x : Int,y : Int) =&gt; x + y}, {(a : Int,b : Int) =&gt; a + b}) def fold(zeroValue:T)(op:(T,T)=&gt;T):T 折叠操作，aggregate的简化操作，seqop和combop一样 var rdd1 = sc.makeRDD(1 to 4,2) rdd1.fold(1)(+) def saveAsTextFile(path:String):Unit 将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本 略 def saveAsObjectFile(path:String):Unit 用于将RDD中的元素序列化成对象，存储到文件中 略 def countByKey():Map[K,Long] 针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)rdd.countByKey() def foreach(f:T=&gt;Unit):Unit 在数据集的每一个元素上，运行函数func进行更新 var rdd = sc.makeRDD(1 to 10,2) var sum = sc.accumulator(0) rdd.foreach(sum+=_) 注意：当在RDD中使用到了class的方法或者属性的时候，该class需要继承java.io.Serializable接口，或者可以将属性赋值为本地变量来防止整个对象的传输]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD的认知（上）]]></title>
    <url>%2F2019%2F08%2F11%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[一、转换操作 函数 解释 案例 def map[U:ClassTag](f:T =&gt; U):RDD[U] 将函数应用于RDD的每一个元素，并返回一个新的RDD val rdd=sc.makeRDD(Array(1,2,3,4,5)) rdd.map((_,1)).collect def filter(f:T =&gt; Boolean):RDD[T] 通过提供的产生boolean条件的表达式来返回符合结果为True的新的RDD val rdd=sc.makeRDD(Array(“aa1”,”aa2”,”bb1”,”bb2”)) rdd.filter(_.startsWith(“aa”)).collect def flatMap[U: ClassTag](f: T =&gt; TraversableOnce[U]): RDD[U] 将函数应用于RDD中的每一项，对于每一项都产生一个集合，并将集合中的元素压扁成一个集合 val rdd=makeRDD(1 to 3) rdd.flatMap((1 to _)).collect def mapPartitions[U:ClassTag](f:Iterator[T] =&gt;Iterator[U],preservesPartitioning:Boolean=false): RDD[U] 将函数应用于RDD的每一个分区，每一个分区运行一次，函数需要能够接受Iterator类型，然后返回Iterator 略 def mapPartitionsWithIndex[U:ClassTag](f:(Int,Iterator[T])=&gt;Iterator[U],preservesPartitioning:Boolean =false):RDD[U] 将函数应用于RDD中的每一个分区，每一个分区运行一次，函数能够接受 一个分区的索引值 和一个代表分区内所有数据的Iterator类型，需要返回Iterator类型 略 def sample(withReplacement: Boolean,fraction:Double,seed:Long=Utils.random.nextLong): RDD[T] 在RDD中以seed为种子返回大致上有fraction比例个数据样本RDD，withReplacement表示是否采用放回式抽样 val sample=sc.makeRDD(1 to 100) sample.sample(false,0.1,4).collect sample.sample(true,0.1,4).collect def union(other:RDD[T]):RDD[T] 将两个RDD中的元素进行合并，返回一个新的RDD val a=sc.makeRDD(1 to 10) sc.makeRDD(5 to 15).union(a).collect def intersection(other:RDD[T]):RDD[T] 将两个RDD做交集，返回一个新的RDD val a=sc.makeRDD(1 to 10) val b=sc.makeRDD(5 to 15) a.intersection(b).collect def distinct():RDD[T] 将当前RDD进行去重后，返回一个新的RDD val dis=sc.makeRDD(List(1,2,3,4,5,2,3,4,1,6,4)） dis.distinct.collect def partitionBy(partitioner:Partitioner):RDD[(K,V)] 根据设置的分区器重新将RDD进行分区，返回新的RDD val par=sc.makeRDD(List((1,”a”),(2,”b”),(3,”c”)),4） par.partitionBy(new org.apache.spark.HashPatitioner(2)) def reduceByKey(func:(V,V)=&gt;V):RDD[(K,V)] 根据Key值将相同Key的元组的值用func进行计算，返回新的RDD val rdd = sc.parallelize(Array(1,2,3,1,2)) rdd.map((,1)) res0.reduceByKey(+_) def groupByKey():RDD[(K,Iterable[V])] 将相同Key的值进行聚集，输出一个(K, Iterable[V])类型的RDD val words=Array(“one”,”one”,”two”,”three”,”three”,”three”) val wordPair=sc.parallelize(words).map((_,1)) val group=wordPair.groupByKey() val map=group.map(t=&gt;(t._1,t._2.sum)) def combineByKey[C](createCombiner:V=&gt;C,mergeValue:(C,V)=&gt; C,mergeCombiners:(C,C)=&gt;C,numPartitions:Int):RDD[(K,C)] 对相同K，把V合并成一个集合.createCombiner: combineByKey()会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过，要么就和之前的某个元素的键相同。如果这是一个新的元素,combineByKey()会使用一个叫作 createCombiner() 的函数来创建那个键对应的累加器的初始值mergeValue:如果这是一个在处理当前分区之前已经遇到的键,它会使用 mergeValue()方法将该键的累加器对应的当前值与这个新的值进行合并mergeCombiners:由于每个分区都是独立处理的，因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器，就需要使用用户提供的 mergeCombiners()方法将各个分区的结果进行合并。 scala&gt; val scores = Array((&quot;Fred&quot;, 88), (&quot;Fred&quot;, 95), (&quot;Fred&quot;, 91), (&quot;Wilma&quot;, 93), (&quot;Wilma&quot;, 95), (&quot;Wilma&quot;, 98)) scores: Array[(String, Int)] = Array((Fred,88), (Fred,95), (Fred,91), (Wilma,93), (Wilma,95), (Wilma,98)) scala&gt; val input = sc.parallelize(scores) input: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[52] at parallelize at &lt;console&gt;:26 scala&gt; val combine = input.combineByKey( ` 待续]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SparkSQL中RDD和DataFrame和DataSet的转换]]></title>
    <url>%2F2019%2F08%2F10%2FRDD%E3%80%81DF%E3%80%81DS%2F</url>
    <content type="text"><![CDATA[RDD ——&gt;DF/DS ——DF: 12345678910//第一种rdd.map&#123; x=&gt;val pa = x.split(&quot;,&quot;);(pa(0).trim,pa(1).trim)&#125;.toDF(&quot;name&quot;,&quot;age&quot;)//-------------------------------------------------------//第二种case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDF ——DS: 1234case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDS DF——RDD/DF ——RDD: DF.rdd获取值，编译器不校验类型 ——DS: 12case class People(name:String,age:Integer)DF.as[People] DS——RDD/DF ——RDD: DS.rdd获取值，编译器校验类型 ——DF: DS.toDF即可]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git——The requested URL returned error 403]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、问题描述hexo部署的仓库需要换到另一个账号上，于是按照之前创建的步骤，修改了hexo安装目录下的deploy的repo地址，然而hexo s和hexo g没出错，但是hexo d时，会出错。 二、问题分析 有可能是你真的没有权限 有可能是修改了git仓库密码和用户名，导致本地内存和硬盘中的用户名和密码不能用 三、问题处理 执行git config --list ，查看git的配置信息 图中的user.email和user.name分别是登录的邮箱和用户名。 打开控制面板-&gt;用户账户-&gt;管理Windows凭据，向下看有普通凭据，找到关于git:https://github.com并删除。 然而我是通过这种方法成功的。 1234//先去根目录root@wangxiaozhang:~/blog cd//再执行来查看credential中缓存的用户root@wangxiaozhang:~# vi .git-credentials 这时我发现这里的代码是我准备要替换的账号名和密码，于是立刻改成现在用的账户名和密码，之后hexo d成功！]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark安装]]></title>
    <url>%2F2019%2F08%2F05%2FSpark%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Spark安装地址 官网地址 http://spark.apache.org 文档查看地址 http://spark.apache.org/docs 下载地址 https://spark.apache.org/downloads.html Standalone模式安装 上传并解压spark安装包 tar -zxvf /opt/softwares/spark-2.4.3-bin-hadoop2.7.tgz -C /opt/module/ 进入spark安装目录下的conf文件夹 cd spark-2.4.3-bin-hadoop2.7/conf 修改配置文件 mv slaves.template slaves mv spark-env.sh.template spark-env.sh 修改slave文件，添加work节点 vi slaves hadoop101 hadoop102 hadoop103 修改spark-env.sh文件，添加如下配置 vi spark-env.sh SPARK_MASTER_HOST=hadoop101 SPARK_MASTER_PROT=7077 分发spark包到其他虚拟机 xsync spark-2.4.3-bin-hadoop2.7 (附分发shell脚本xsync) 12345678910111213141516171819202122232425#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do #echo $pdir/$fname $user@hadoop$host:$pdir echo --------------- hadoop$host ---------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 启动 sbin/start-all.sh 123456789101112131415161718192021[wangzichen@hadoop101 spark-2.4.3-bin-hadoop2.7]$ jps.sh ================wangzichen@hadoop101================3330 Jps3238 Worker3163 Master================wangzichen@hadoop102================2966 Jps2908 Worker================wangzichen@hadoop103================2978 Worker3036 Jps 启动spark shell 1234/opt/module/spark-2.4.3-bin-hadoop2.7/bin/spark-shell \--master spark://hadoop101:7077 \--executor-memory 1g \--total-executor-cores 2 注意：如果启动spark shell时没有指定master地址，但是也可以正常启动spark shell和执行spark shell中的程序，其实是启动了spark的local模式，该模式仅在本机启动一个进程，没有与集群建立联系 。 Spark Shell中已经默认将SparkContext类初始化为对象sc。用户代码如果需要用到，则直接应用sc即可 。 JobHistoryServer配置 修改spark-default.conf.template名称 mv spark-defaults.conf.template spark-defaults.conf 修改spark-default.conf文件，开启log 123vi spark-defaults.confspark.eventLog.enabled //truespark.eventLog.dir //hdfs://hadoop101:9000/directory（若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错） 注意：HDFS上的目录需要提前存在 修改spark-env.sh文件，添加如下配置 1234vi spark-env.shexport SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://hadoop101:9000/directory&quot; //若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错 分发配置文件到其他虚拟机 12xsync spark-defaults.confxsync spark-env.sh 启动历史服务 sbin/start-history-server.sh 测试，执行任务长度 1234567bin/spark-submit \--class org.apache.spark.examples.SparkPi \--master spark://hadoop101:7077 \--executor-memory 1G \--total-executor-cores 2 \./examples/jars/spark-examples_2.11-2.4..jar \100 查看历史服务 在浏览器上输入hadoop101:4000查看 Yarn模式安装 修改hadoop配置文件yarn-site.xml，并添加如下内容 1234567891011vi yarn-site.xml&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; 修改spark-env.sh，添加如下配置 123vi spark-env.shYARN_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop HADOOP_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop 分发配置文件 12xsync /opt/module/hadoop-2.7.2/etc/hadoop/yarn-site.xmlxsync spark-env.sh]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark初识]]></title>
    <url>%2F2019%2F08%2F04%2FSpark%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spark简介(官网的解释Spark官网) Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。项目是用Scala进行编写。 Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLib、SparkR等子项目，Spark是基于内存计算的大数据并行计算框架。除了扩展了广泛使用的 MapReduce 计算模型，而且高效地支持更多计算模式，包括交互式查询和流处理。Spark 适用于各种各样原先需要多种不同的分布式平台的场景，包括批处理、迭代算法、交互式查询、流处理。通过在一个统一的框架下支持这些不同的计算，Spark 使我们可以简单而低耗地把各种处理流程整合在一起。而这样的组合，在实际的数据分析 过程中是很有意义的。不仅如此，Spark 的这种特性还大大减轻了原先需要对各种平台分 别管理的负担。 大一统的软件栈，各个组件关系密切并且可以相互调用，这种设计有几个好处：1、软件栈中所有的程序库和高级组件 都可以从下层的改进中获益。2、运行整个软件栈的代价变小了。不需要运 行 5 到 10 套独立的软件系统了，一个机构只需要运行一套软件系统即可。系统的部署、维护、测试、支持等大大缩减。3、能够构建出无缝整合不同处理模型的应用。 Spark内置项目如下： Spark Core:实现了 Spark 的基本功能，包含任务调度、内存管理、错误恢复、与存储系统 交互等模块。Spark Core 中还包含了对弹性分布式数据集(resilient distributed dataset，简称RDD)的 API 定义 。 Spark SQL:是 Spark 用来操作结构化数据的程序包。通过 Spark SQL，我们可以使用 SQL 或者 Apache Hive 版本的 SQL 方言(HQL)来查询数据。Spark SQL 支持多种数据源，比 如 Hive 表、Parquet 以及 JSON 等。 Spark Streaming:是 Spark 提供的对实时数据进行流式计算的组件。提供了用来操作数据流的 API，并且与 Spark Core 中的 RDD API 高度对应。 Spark MLlib:提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 Spark特点 快：与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中的。 易用：Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用：Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。 兼容性：Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 Spark角色及运行模式集群角色从物理部署层面上来看，Spark主要分为两种类型的节点，Master节点和Worker节点：Master节点主要运行集群管理器的中心化部分，所承载的作用是分配Application到Worker节点，维护Worker节点，Driver，Application的状态。Worker节点负责具体的业务运行。 从Spark程序运行的层面来看，Spark主要分为驱动器节点和执行器节点。 运行模式 Local模式：Local模式就是运行在一台计算机上的模式，通常就是用于在本机上练手和测试。它可以通过以下集中方式设置master。 local: 所有计算都运行在一个线程当中，没有任何并行计算，通常我们在本机执行一些测试代码，或者练手，就用这种模式; local[K]: 指定使用几个线程来运行计算，比如local[4]就是运行4个worker线程。通常我们的cpu有几个core，就指定几个线程，最大化利用cpu的计算能力; local[*]: 这种模式直接帮你按照cpu最多cores来设置线程数了。 Standalone模式：构建一个由Master+Slave构成的Spark集群，Spark运行在集群中。 Yarn模式：Spark客户端直接连接Yarn；不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。 yarn-client：Driver程序运行在客户端，适用于交互、调试，希望立即看到app的输出。 yarn-cluster：Driver程序运行在由RM（ResourceManager）启动的AP（APPMaster）适用于生产环境。 Mesos模式：Spark客户端直接连接Mesos；不需要额外构建Spark集群。国内应用比较少，更多的是运用yarn调度。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
</search>
