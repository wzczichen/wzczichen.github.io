<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spark安装]]></title>
    <url>%2F2019%2F08%2F05%2FSpark%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Spark安装地址 官网地址 http://spark.apache.org 文档查看地址 http://spark.apache.org/docs 下载地址 https://spark.apache.org/downloads.html Standalone模式安装 上传并解压spark安装包 tar -zxvf /opt/softwares/spark-2.4.3-bin-hadoop2.7.tgz -C /opt/module/ 进入spark安装目录下的conf文件夹 cd spark-2.4.3-bin-hadoop2.7/conf 修改配置文件 mv slaves.template slaves mv spark-env.sh.template spark-env.sh 修改slave文件，添加work节点 vi slaves hadoop101 hadoop102 hadoop103 修改spark-env.sh文件，添加如下配置 vi spark-env.sh SPARK_MASTER_HOST=hadoop101 SPARK_MASTER_PROT=7077 分发spark包到其他虚拟机 xsync spark-2.4.3-bin-hadoop2.7 (附分发shell脚本xsync) 12345678910111213141516171819202122232425#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do #echo $pdir/$fname $user@hadoop$host:$pdir echo --------------- hadoop$host ---------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 启动 sbin/start-all.sh 123456789101112131415161718192021[wangzichen@hadoop101 spark-2.4.3-bin-hadoop2.7]$ jps.sh ================wangzichen@hadoop101================3330 Jps3238 Worker3163 Master================wangzichen@hadoop102================2966 Jps2908 Worker================wangzichen@hadoop103================2978 Worker3036 Jps 启动spark shell 1234/opt/module/spark-2.4.3-bin-hadoop2.7/bin/spark-shell \--master spark://hadoop101:7077 \--executor-memory 1g \--total-executor-cores 2 注意：如果启动spark shell时没有指定master地址，但是也可以正常启动spark shell和执行spark shell中的程序，其实是启动了spark的local模式，该模式仅在本机启动一个进程，没有与集群建立联系 。 Spark Shell中已经默认将SparkContext类初始化为对象sc。用户代码如果需要用到，则直接应用sc即可 。 JobHistoryServer配置 修改spark-default.conf.template名称 mv spark-defaults.conf.template spark-defaults.conf 修改spark-default.conf文件，开启log 123vi spark-defaults.confspark.eventLog.enabled //truespark.eventLog.dir //hdfs://hadoop101:9000/directory（若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错） 注意：HDFS上的目录需要提前存在 修改spark-env.sh文件，添加如下配置 1234vi spark-env.shexport SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://hadoop101:9000/directory&quot; //若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错 分发配置文件到其他虚拟机 12xsync spark-defaults.confxsync spark-env.sh 启动历史服务 sbin/start-history-server.sh 测试，执行任务长度 1234567bin/spark-submit \--class org.apache.spark.examples.SparkPi \--master spark://hadoop101:7077 \--executor-memory 1G \--total-executor-cores 2 \./examples/jars/spark-examples_2.11-2.4..jar \100 查看历史服务 在浏览器上输入hadoop101:4000查看 Yarn模式安装 修改hadoop配置文件yarn-site.xml，并添加如下内容 1234567891011vi yarn-site.xml&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; 修改spark-env.sh，添加如下配置 123vi spark-env.shYARN_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop HADOOP_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop 分发配置文件 12xsync /opt/module/hadoop-2.7.2/etc/hadoop/yarn-site.xmlxsync spark-env.sh]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark初识]]></title>
    <url>%2F2019%2F08%2F04%2FSpark%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spark简介(官网的解释Spark官网) Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。项目是用Scala进行编写。 Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLib、SparkR等子项目，Spark是基于内存计算的大数据并行计算框架。除了扩展了广泛使用的 MapReduce 计算模型，而且高效地支持更多计算模式，包括交互式查询和流处理。Spark 适用于各种各样原先需要多种不同的分布式平台的场景，包括批处理、迭代算法、交互式查询、流处理。通过在一个统一的框架下支持这些不同的计算，Spark 使我们可以简单而低耗地把各种处理流程整合在一起。而这样的组合，在实际的数据分析 过程中是很有意义的。不仅如此，Spark 的这种特性还大大减轻了原先需要对各种平台分 别管理的负担。 大一统的软件栈，各个组件关系密切并且可以相互调用，这种设计有几个好处：1、软件栈中所有的程序库和高级组件 都可以从下层的改进中获益。2、运行整个软件栈的代价变小了。不需要运 行 5 到 10 套独立的软件系统了，一个机构只需要运行一套软件系统即可。系统的部署、维护、测试、支持等大大缩减。3、能够构建出无缝整合不同处理模型的应用。 Spark内置项目如下： Spark Core:实现了 Spark 的基本功能，包含任务调度、内存管理、错误恢复、与存储系统 交互等模块。Spark Core 中还包含了对弹性分布式数据集(resilient distributed dataset，简称RDD)的 API 定义 。 Spark SQL:是 Spark 用来操作结构化数据的程序包。通过 Spark SQL，我们可以使用 SQL 或者 Apache Hive 版本的 SQL 方言(HQL)来查询数据。Spark SQL 支持多种数据源，比 如 Hive 表、Parquet 以及 JSON 等。 Spark Streaming:是 Spark 提供的对实时数据进行流式计算的组件。提供了用来操作数据流的 API，并且与 Spark Core 中的 RDD API 高度对应。 Spark MLlib:提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 Spark特点 快：与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中的。 易用：Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用：Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。 兼容性：Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 Spark角色及运行模式集群角色从物理部署层面上来看，Spark主要分为两种类型的节点，Master节点和Worker节点：Master节点主要运行集群管理器的中心化部分，所承载的作用是分配Application到Worker节点，维护Worker节点，Driver，Application的状态。Worker节点负责具体的业务运行。 从Spark程序运行的层面来看，Spark主要分为驱动器节点和执行器节点。 运行模式 Local模式：Local模式就是运行在一台计算机上的模式，通常就是用于在本机上练手和测试。它可以通过以下集中方式设置master。 local: 所有计算都运行在一个线程当中，没有任何并行计算，通常我们在本机执行一些测试代码，或者练手，就用这种模式; local[K]: 指定使用几个线程来运行计算，比如local[4]就是运行4个worker线程。通常我们的cpu有几个core，就指定几个线程，最大化利用cpu的计算能力; local[*]: 这种模式直接帮你按照cpu最多cores来设置线程数了。 Standalone模式：构建一个由Master+Slave构成的Spark集群，Spark运行在集群中。 Yarn模式：Spark客户端直接连接Yarn；不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。 yarn-client：Driver程序运行在客户端，适用于交互、调试，希望立即看到app的输出。 yarn-cluster：Driver程序运行在由RM（ResourceManager）启动的AP（APPMaster）适用于生产环境。 Mesos模式：Spark客户端直接连接Mesos；不需要额外构建Spark集群。国内应用比较少，更多的是运用yarn调度。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
</search>
