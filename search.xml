<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flink(基础)]]></title>
    <url>%2F2019%2F10%2F12%2FFlink%2F</url>
    <content type="text"><![CDATA[FlinkSpark分实时部分和离线部分，Flink还是替代不了离线部分，Spark和Hive可以无缝整合，Flink暂时还达不到，还没有官方的支持，实时部分和Spark平起平坐 特点：事件驱动型以事件为单位的计算，一件事一件事的处理，kafka的通道里的单元，flume的channel里的event也是，SparkStreaming是微批次，数据进入spark的时候会定义一个批次的时间，是以时间为单位而不是以事件为单位的，区别：对数据更加敏感。会减少数据的延迟性。 流和批的世界观批处理的特点是有界、持久、大量，非常适合需要访问全套记录才能完成的计算工作，一般用于离线统计。 流处理的特点是无界、实时, 无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。 分层Api spark也分层，比如RDD操作这是一层，还有一层SQL，本质来说都是RDD的，转义到SQL DataStream 实时的，DataSet 离线的，处于中间层，灵活。类似于map，filter，reduceByKey等等，和Spark的算子很像。 高级层有SQL和Table Api，TableApi像.select().where().groupBy()，好处是代码简介，利于读懂，偏向业务逻辑 低级层 有状态计算spark也有有状态计算，类似于updatastatebykey，把状态存在checkpoint里。 flink也有状态的维护，一般存在redis里，也可以存在checkpoint里。但是说到底checkpoint只是个机制，检查点机制，checkpoint存在哪儿是可以选择的，可以放在磁盘和内存中和HDFS中 Flink state两种 operator state:操作状态，整个的数据流在每一个算子中计算，计算完成还是没完成会把这个状态存起来，为了后续的提交操作。相当于存的执行的情况 Keyed state:以key为单位，存的值就是state。相当于存的业务的数据 无状态计算会观察每个独立的事件，并且会在最后一个时间出结果，例如一些报警和监控，一直观察每个事件，当触发警报的事件来临就会触发警告。 有状态的计算就会基于多个事件来输出结果，比如说计算过去一个小时的平均温度等等。 支持Exactly-once语义希望有且只执行一次，数据处理最佳的状态 At Most once:最多一条或者没有，这种情况会造成数据丢失 At Least once:最少一次，一旦我觉得发送失败了，就再发送一次，可是我觉得发送失败了，不一定就真的发送失败了，有误判，会造成数据的重复 Exactly-once:如果我发送成功了，不会再发，如果没成功，一定会再发 spark官方达不到Exactly-once的状态 spark可以人为的操作来实现Exactly-once状态。数据一进来就提交，中间处理失败了，kafka不会认为处理失败了，这件事已经过去了，已经处理成功了，可以在末尾提交，需要人为的把提交的操作摞到某一个业务点，确认处理完成后提交，即调整kafka的偏移量offset，如偏移量放在zookeeper，需要自己去调整zookeeper Flink自己帮你完成了，每个操作都有自己的状态 支持事件事件（Eventtime）目前大多数框架时间窗口计算，都是采用当前系统时间，以时间为单位进行的聚合计算只能反应数据到达计算引擎的时间，而并不是实际业务时间 例如，spark的开窗函数，开一个window，取最近一小时，指数据流到spark的一小时，不管数据是什么时候产生的不关心，只以数据进入spark为准]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10更新到1903后,出现Vmware workstation pro无法打开]]></title>
    <url>%2F2019%2F10%2F04%2FVmware%2F</url>
    <content type="text"><![CDATA[时间：2019年10月份 在这个更新后，我的vmware workstation pro无法打开，提示需要安装最新版本，然而又不能打开检查更新，只能卸载再安装了15.5的版本。 问题：安装了之后无法ping和上网说明：之前配过3台的虚拟机集群，所以安装完之后直接打开，可以通过ifconfig显示ip，各个虚拟机之间可以ping，而且ssh也可以。但是每个都无法ping主机和www.baidu.com。第一步：切换为root权限，查看/etc/sysconfig/network-scripts/ifcfg-enoXXXX，看看是否有误! 第二步：查看服务，关于vmware的服务是否都已经启动第三步：打开windows的网络连接，查看 第四步：打开vmware的编辑，打开虚拟机网络编辑器，查看VMnet8的子网地址的前三位是否和自己配置的静态ip的前三位相等，若是不相同，把Vmnet8的子网地址前三位改为和虚拟机ip前三位相同即可。 第五步：查看网络适配器 测试：ping主机和baidu.com 成功！]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop+hbase启动出现的问题]]></title>
    <url>%2F2019%2F09%2F18%2Fhadoop-hbase%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.集群描述：三台虚拟机搭建 hadoop101 hadoop102 hadoop103 Datanode Datanode Datanode Namenode QuorumPeerMain QuorumPeerMain QuorumPeerMain NodeManager NodeManager NodeManager ResourceManager SecondaryNameNode HRegionServer HRegionServer HRegionServer HMaster Jps Jps Jps 2.问题的过程首先，Hadoop101作为三台虚拟机中的最重要的，平时安装时都十分小心，Hadoop102和Hadoop103由于有一次VMware关机时卡死，直接通过ctrl+shift+delete强制结束进程，导致Hadoop102的文件损坏，于是我克隆了Hadoop103，再把ip等一些配置重新配置了一下（最主要的是zookeeper的data/zkData/myid（这个位置是自己定义的dataDir的地址），以及kafka的conf/server.properties里的broker.id=#，每个虚拟机都不相同）。在我运行如下的shell脚本，一键启动后 1234567891011121314151617181920212223242526272829303132333435#!/bin/bashecho "=================正在开启集群服务==================="echo "================正在开启zookeeper服务=================="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh start'doneecho "=============正在开启NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start namenode'echo "=============正在开启DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start datanode'doneecho "=============正在开启SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start secondarynamenode'echo "==========正在开启ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start resourcemanager'echo "==============正在开启NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start nodemanager'done# echo "============正在开启JobHistoryServer============"# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh start historyserver'echo "============正在开启Hbase节点============"ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/start-hbase.sh' 出现了两个问题： HMaster出现一会儿就消失，其他都正常 HMaster正常，Hadoop102或者Hadoop103的DataNode其中一个过会儿会消失 摸索了一个下午，终于解决了，只是不清楚为什么会好了，以下是我改的部分。 1.我改了hbase安装目录下的conf/hbase-env.sh的export HBASE_MANAGES_ZK=false，将其开头的#去除2.我发现hbase安装目录下的conf/hbase-site.xml的zookeeper的dataDir地址填错了1234&lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/modules/zookeeper-3.4.10/data/zkData&lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群启动脚本全]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%9B%86%E7%BE%A4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[大数据集群启动脚本1234567891011121314151617181920212223242526272829303132333435#!/bin/bashecho "=============正在开启集群服务================="echo "===============正在开启zookeeper服务================"for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh start'doneecho "=============正在开启NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start namenode'echo "=============正在开启DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start datanode'doneecho "=============正在开启SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh start secondarynamenode'echo "==========正在开启ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start resourcemanager'echo "==============正在开启NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh start nodemanager'done# echo "============正在开启JobHistoryServer============"# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh start historyserver'echo "============正在开启Hbase节点============"ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/start-hbase.sh' 关闭脚本12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashecho "=============正在关闭集群服务================="echo "=============正在关闭HBase节点============="ssh wangzichen@hadoop101 '/opt/modules/hbase-1.2.0/bin/stop-hbase.sh'# echo "=============正在关闭JobHistoryServer节点============="# ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh stop historyserver'echo "==========正在关闭ResourceManager节点=========="ssh wangzichen@hadoop102 '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh stop resourcemanager'echo "==============正在关闭NodeManager=============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/yarn-daemon.sh stop nodemanager'doneecho "=============正在关闭NameNode节点============="ssh wangzichen@hadoop101 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop namenode'echo "=============正在关闭SecondaryNameNode节点============="ssh wangzichen@hadoop103 '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop secondarynamenode'echo "=============正在关闭DataNode节点============="for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/hadoop-2.7.2/sbin/hadoop-daemon.sh stop datanode'doneecho "===============正在关闭zookeeper服务================"for i in wangzichen@hadoop101 wangzichen@hadoop102 wangzichen@hadoop103do ssh $i '/opt/modules/zookeeper-3.4.10/bin/zkServer.sh stop'done 查询启动服务脚本12345678#!/bin/sh#查看各个主机的java进程for HOST in hadoop101 hadoop102 hadoop103do echo ===================== $HOST ======================= ssh $HOST "jps"done]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装及问题"net/http:TLS handshake timeout"]]></title>
    <url>%2F2019%2F09%2F01%2FDocker%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[一、安装Docker步骤： 123456789101112131415161718192021//******需要root权限******//1.检查内核版本，必须是3.10及以上使用命令 uname -r2.安装dockeryum install docker3.安装过程中需要确认，输入y即可4.启动dockersystemctl start docker查看版本docker -vDocker version 1.13.1, build 7f2769b/1.13.15.设置开机启动dockersystemctl enable dockerCreated symlink from /etc/systemd/system/multi‐user.target.wants/docker.service to/usr/lib/systemd/system/docker.service. 6.停止dockersystemctl stop docker 二、Docker常见命令及操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 例：docker search redis 去docker hub检索镜像的详细信息，如镜像的Tag 拉取 docker pull 镜像名:tag 例：docker pull redis 其中:tag是可选的，tag表示标签，是软件的版本，不设置默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（类似于lol客户端）—–运行镜像—-产生了一个容器（lol正在运行） 步骤： 12345678910111213141516171819202122232425262728291、搜索镜像docker search tomcat2、拉取镜像docker pull tomcat3、根据镜像启动容器docker run ‐‐name mytomcat ‐d tomcat:latest4、查看运行中的容器docker ps5.停止运行中的容器docker stop id6.查看所有的容器docker ps -a7.启动容器docker start id8.删除一个容器docker rm id9.启动一个有端口映射的tomcatdocker run -d -p 8888:8080 mytomcat//-d：后台运行//-p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口10.关闭linux的防火墙service firewall status //查看防火墙的状态service firewall stop //关闭防火墙11.查看容器的日志docker logs id/***更多命令参考文档https://docs.docker.com/engine/reference/commandline/docker/*/ 注意点： 当docker search 关键字后，准备docker pull 关键字时，命令行会出现“net/http: TLS handshake timeout”，这是由于docker默认镜像拉取地址为国外仓库，下载速度慢，我们只需要将拉取地址修改为国内镜像仓库即可（可使用阿里云提供的加速服务） 阿里云容器镜像服务 首先会让你登录账号，一步步来，之后左侧栏底部有镜像加速器，点进去可以看到类似于https://xxxxxx.mirror.aliyuncs.com的加速器地址，xxxxx每个人的都不一样，将它先复制，打开安装docker的虚拟机或者主机。 123456789//1.输入命令vi /etc/docker/daemon.json//2.按照如下修改&#123; "registry-mirrors": ["https://xxxxxx.mirror.aliyuncs.com"]&#125;//3.重启docker服务 docker删除镜像文件时，出现image is referenced in multiple repositories如何解决? ​ 我们可以发现这两个都是redis，只是版本号不同，IMAGE ID两个都一样，因此无法删除。 ​ 但是可以用repository和tag的方式来删除 121.docker rmi docker.io/redis //先根据repository删除一个2.docker rmi f7302e4ab3a8 //再用id删除一个]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA导入项目报错non-managed pom.xml file found]]></title>
    <url>%2F2019%2F08%2F16%2FIDEA-bug%2F</url>
    <content type="text"><![CDATA[第一步：点击右侧的maven视图 第二步：选择需要添加的pox.xml文件 第三步：选择项目运行需要的SDK OVER]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD认知(下)]]></title>
    <url>%2F2019%2F08%2F12%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[一、转换操作(续) 函数 解释 示例 def aggregateByKey[U:ClassTag](zeroValue:U,partitioner:Partitioner)(seqOp:(U,V)=&gt;U,combOp:(U,U)=&gt;U):RDD[(K,U)] 通过seqOp函数将每一个分区里面的数据和初始值迭代带入函数返回最终值，comOp将每一个分区返回的最终值根据key进行合并操作 略 def foldByKey(zeroValue:V,partitioner:Partitioner)(func:(V,V)=&gt;V):RDD[(K,V)] aggregateByKey的简化操作，seqop和combop相同 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)val agg = rdd.foldByKey(0)(+).collect def sortByKey(ascending:Boolean=true,numPartitions:Int=self.partitions.length):RDD[(K,V)] 在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD val rdd = sc.parallelize(Array((3,”aa”),(6,”cc”),(2,”bb”),(1,”dd”))) rdd.sortByKey(true).collect() def sortBy[K](f:(T)=&gt;K,ascending:Boolean=true,numPartitions:Int = this.partitions.length)(implicit ord:Ordering[K],ctag:ClassTag[K]):RDD[T] 底层实现还是使用sortByKey，只不过使用fun生成的新key进行排序 val rdd = sc.parallelize(List(1,2,3,4)) rdd.sortBy(x =&gt; x%3).collect() def join[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(V,W))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD val rdd1= sc.parallelize(Array((1,”a”),(2,”b”),(3,”c”)))) val rdd2 = sc.parallelize(Array((1,4),(2,5),(3,6))) rdd1.join(rdd2).collect() def cogroup[W](other:RDD[(K,W)],partitioner:Partitioner):RDD[(K,(Iterable[V], Iterable[W]))] 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable,Iterable))类型的RDD 略 def cartesian[U:ClassTag](other:RDD[U]):RDD[(T,U)] 笛卡尔积 val rdd1 = sc.parallelize(1 to 3) val rdd2 = sc.parallelize(2 to 5) rdd1.cartesian(rdd2).collect() def pipe(command:String):RDD[String] 对于每个分区，都执行一个perl或者shell脚本，返回输出的RDD 略 def coalesce(numPartitions:Int,shuffle:Boolean=false,partitionCoalescer: Option[PartitionCoalescer]=Option.empty)(implicit ord:Ordering[T]=null):RDD[T] 缩减分区数，用于大数据集过滤后，提高小数据集的执行效率 略 def repartition(numPartitions:Int)(implicit ord:Ordering[T]=null):RDD[T] 根据分区数,重新通过网络随机洗牌所有数据 略 def repartitionAndSortWithinPartitions(partitioner:Partitioner):RDD[(K,V)] repartitionAndSortWithinPartitions函数是repartition函数的变种，与repartition函数不同的是，repartitionAndSortWithinPartitions在给定的partitioner内部进行排序，性能比repartition要高 略 def glom():RDD[Array[T]] 将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]] val rdd = sc.parallelize(1 to 16,4) rdd.glom().collect() def mapValues[U](f:V=&gt;U):RDD[(K,U)] 针对于(K,V)形式的类型只对V进行操作 val rdd3 = sc.parallelize(Array((1,”a”),(1,”d”),(2,”b”),(3,”c”))) rdd3.mapValues(_+”|||”).collect() def subtract(other:RDD[T]):RDD[T] 计算差的一种函数去除两个RDD中相同的元素，不同的RDD将保留下来 val rdd = sc.parallelize(3 to 8) val rdd1 = sc.parallelize(1 to 5) rdd.subtract(rdd1).collect() 二、行动操作 函数 解释 示例 def takeSample(withReplacement:Boolean,num:Int,seed:Long=Utils.random.nextLong):Array[T] 返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子 val rdd=sc.parallelize(1 to 10,2)rdd.takeSample(true,5,3) def reduce(f:(T,T)=&gt;T):T 通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的 val rdd1 = sc.makeRDD(1 to 10,2) rdd1.reduce(+) def collect():Array[T] 在驱动程序中，以数组的形式返回数据集的所有元素 太常用，略 def count():Long 返回RDD的元素个数 略 def first():T 返回RDD的第一个元素（类似于take(1)) 略 def take(num:Int):Array[T] 返回一个由数据集的前n个元素组成的数组 略 def takeOrdered(num:Int)(implicit ord:Ordering[T]) 返回前几个的排序 略 def aggregate[U:ClassTag](zeroValue:U)(seqOp:(U,T)=&gt;U,combOp:(U,U)=&gt;U):U aggregate函数将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。这个函数最终返回的类型不需要和RDD中元素类型一致 scala&gt; var rdd1 = sc.makeRDD(1 to 10,2) scala&gt;rdd1.aggregate(1){(x : Int,y : Int) =&gt; x + y}, {(a : Int,b : Int) =&gt; a + b}) def fold(zeroValue:T)(op:(T,T)=&gt;T):T 折叠操作，aggregate的简化操作，seqop和combop一样 var rdd1 = sc.makeRDD(1 to 4,2) rdd1.fold(1)(+) def saveAsTextFile(path:String):Unit 将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本 略 def saveAsObjectFile(path:String):Unit 用于将RDD中的元素序列化成对象，存储到文件中 略 def countByKey():Map[K,Long] 针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数 val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)rdd.countByKey() def foreach(f:T=&gt;Unit):Unit 在数据集的每一个元素上，运行函数func进行更新 var rdd = sc.makeRDD(1 to 10,2) var sum = sc.accumulator(0) rdd.foreach(sum+=_) 注意：当在RDD中使用到了class的方法或者属性的时候，该class需要继承java.io.Serializable接口，或者可以将属性赋值为本地变量来防止整个对象的传输]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDD的认知（上）]]></title>
    <url>%2F2019%2F08%2F11%2FRDD%E7%9A%84%E8%AE%A4%E7%9F%A5(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[一、转换操作 函数 解释 案例 def map[U:ClassTag](f:T =&gt; U):RDD[U] 将函数应用于RDD的每一个元素，并返回一个新的RDD val rdd=sc.makeRDD(Array(1,2,3,4,5)) rdd.map((_,1)).collect def filter(f:T =&gt; Boolean):RDD[T] 通过提供的产生boolean条件的表达式来返回符合结果为True的新的RDD val rdd=sc.makeRDD(Array(“aa1”,”aa2”,”bb1”,”bb2”)) rdd.filter(_.startsWith(“aa”)).collect def flatMap[U: ClassTag](f: T =&gt; TraversableOnce[U]): RDD[U] 将函数应用于RDD中的每一项，对于每一项都产生一个集合，并将集合中的元素压扁成一个集合 val rdd=makeRDD(1 to 3) rdd.flatMap((1 to _)).collect def mapPartitions[U:ClassTag](f:Iterator[T] =&gt;Iterator[U],preservesPartitioning:Boolean=false): RDD[U] 将函数应用于RDD的每一个分区，每一个分区运行一次，函数需要能够接受Iterator类型，然后返回Iterator 略 def mapPartitionsWithIndex[U:ClassTag](f:(Int,Iterator[T])=&gt;Iterator[U],preservesPartitioning:Boolean =false):RDD[U] 将函数应用于RDD中的每一个分区，每一个分区运行一次，函数能够接受 一个分区的索引值 和一个代表分区内所有数据的Iterator类型，需要返回Iterator类型 略 def sample(withReplacement: Boolean,fraction:Double,seed:Long=Utils.random.nextLong): RDD[T] 在RDD中以seed为种子返回大致上有fraction比例个数据样本RDD，withReplacement表示是否采用放回式抽样 val sample=sc.makeRDD(1 to 100) sample.sample(false,0.1,4).collect sample.sample(true,0.1,4).collect def union(other:RDD[T]):RDD[T] 将两个RDD中的元素进行合并，返回一个新的RDD val a=sc.makeRDD(1 to 10) sc.makeRDD(5 to 15).union(a).collect def intersection(other:RDD[T]):RDD[T] 将两个RDD做交集，返回一个新的RDD val a=sc.makeRDD(1 to 10) val b=sc.makeRDD(5 to 15) a.intersection(b).collect def distinct():RDD[T] 将当前RDD进行去重后，返回一个新的RDD val dis=sc.makeRDD(List(1,2,3,4,5,2,3,4,1,6,4)） dis.distinct.collect def partitionBy(partitioner:Partitioner):RDD[(K,V)] 根据设置的分区器重新将RDD进行分区，返回新的RDD val par=sc.makeRDD(List((1,”a”),(2,”b”),(3,”c”)),4） par.partitionBy(new org.apache.spark.HashPatitioner(2)) def reduceByKey(func:(V,V)=&gt;V):RDD[(K,V)] 根据Key值将相同Key的元组的值用func进行计算，返回新的RDD val rdd = sc.parallelize(Array(1,2,3,1,2)) rdd.map((,1)) res0.reduceByKey(+_) def groupByKey():RDD[(K,Iterable[V])] 将相同Key的值进行聚集，输出一个(K, Iterable[V])类型的RDD val words=Array(“one”,”one”,”two”,”three”,”three”,”three”) val wordPair=sc.parallelize(words).map((_,1)) val group=wordPair.groupByKey() val map=group.map(t=&gt;(t._1,t._2.sum)) def combineByKey[C](createCombiner:V=&gt;C,mergeValue:(C,V)=&gt; C,mergeCombiners:(C,C)=&gt;C,numPartitions:Int):RDD[(K,C)] 对相同K，把V合并成一个集合.createCombiner: combineByKey()会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过，要么就和之前的某个元素的键相同。如果这是一个新的元素,combineByKey()会使用一个叫作 createCombiner() 的函数来创建那个键对应的累加器的初始值mergeValue:如果这是一个在处理当前分区之前已经遇到的键,它会使用 mergeValue()方法将该键的累加器对应的当前值与这个新的值进行合并mergeCombiners:由于每个分区都是独立处理的，因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器，就需要使用用户提供的 mergeCombiners()方法将各个分区的结果进行合并。 scala&gt; val scores = Array((&quot;Fred&quot;, 88), (&quot;Fred&quot;, 95), (&quot;Fred&quot;, 91), (&quot;Wilma&quot;, 93), (&quot;Wilma&quot;, 95), (&quot;Wilma&quot;, 98)) scores: Array[(String, Int)] = Array((Fred,88), (Fred,95), (Fred,91), (Wilma,93), (Wilma,95), (Wilma,98)) scala&gt; val input = sc.parallelize(scores) input: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[52] at parallelize at &lt;console&gt;:26 scala&gt; val combine = input.combineByKey( ` 待续]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SparkSQL中RDD和DataFrame和DataSet的转换]]></title>
    <url>%2F2019%2F08%2F10%2FRDD%E3%80%81DF%E3%80%81DS%2F</url>
    <content type="text"><![CDATA[RDD ——&gt;DF/DS ——DF: 12345678910//第一种rdd.map&#123; x=&gt;val pa = x.split(&quot;,&quot;);(pa(0).trim,pa(1).trim)&#125;.toDF(&quot;name&quot;,&quot;age&quot;)//-------------------------------------------------------//第二种case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDF ——DS: 1234case class People(name:String,age:Integer)rdd.map&#123; x=&gt;val pa=x.split(&quot;,&quot;);People(pa(0).trim,pa(1).trim)&#125;.toDS DF——RDD/DF ——RDD: DF.rdd获取值，编译器不校验类型 ——DS: 12case class People(name:String,age:Integer)DF.as[People] DS——RDD/DF ——RDD: DS.rdd获取值，编译器校验类型 ——DF: DS.toDF即可]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git——The requested URL returned error 403]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、问题描述hexo部署的仓库需要换到另一个账号上，于是按照之前创建的步骤，修改了hexo安装目录下的deploy的repo地址，然而hexo s和hexo g没出错，但是hexo d时，会出错。 二、问题分析 有可能是你真的没有权限 有可能是修改了git仓库密码和用户名，导致本地内存和硬盘中的用户名和密码不能用 三、问题处理 执行git config --list ，查看git的配置信息 图中的user.email和user.name分别是登录的邮箱和用户名。 打开控制面板-&gt;用户账户-&gt;管理Windows凭据，向下看有普通凭据，找到关于git:https://github.com并删除。 然而我是通过这种方法成功的。 1234//先去根目录root@wangxiaozhang:~/blog cd//再执行来查看credential中缓存的用户root@wangxiaozhang:~# vi .git-credentials 这时我发现这里的代码是我准备要替换的账号名和密码，于是立刻改成现在用的账户名和密码，之后hexo d成功！]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark安装]]></title>
    <url>%2F2019%2F08%2F05%2FSpark%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Spark安装地址 官网地址 http://spark.apache.org 文档查看地址 http://spark.apache.org/docs 下载地址 https://spark.apache.org/downloads.html Standalone模式安装 上传并解压spark安装包 tar -zxvf /opt/softwares/spark-2.4.3-bin-hadoop2.7.tgz -C /opt/module/ 进入spark安装目录下的conf文件夹 cd spark-2.4.3-bin-hadoop2.7/conf 修改配置文件 mv slaves.template slaves mv spark-env.sh.template spark-env.sh 修改slave文件，添加work节点 vi slaves hadoop101 hadoop102 hadoop103 修改spark-env.sh文件，添加如下配置 vi spark-env.sh SPARK_MASTER_HOST=hadoop101 SPARK_MASTER_PROT=7077 分发spark包到其他虚拟机 xsync spark-2.4.3-bin-hadoop2.7 (附分发shell脚本xsync) 12345678910111213141516171819202122232425#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do #echo $pdir/$fname $user@hadoop$host:$pdir echo --------------- hadoop$host ---------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 启动 sbin/start-all.sh 123456789101112131415161718192021[wangzichen@hadoop101 spark-2.4.3-bin-hadoop2.7]$ jps.sh ================wangzichen@hadoop101================3330 Jps3238 Worker3163 Master================wangzichen@hadoop102================2966 Jps2908 Worker================wangzichen@hadoop103================2978 Worker3036 Jps 启动spark shell 1234/opt/module/spark-2.4.3-bin-hadoop2.7/bin/spark-shell \--master spark://hadoop101:7077 \--executor-memory 1g \--total-executor-cores 2 注意：如果启动spark shell时没有指定master地址，但是也可以正常启动spark shell和执行spark shell中的程序，其实是启动了spark的local模式，该模式仅在本机启动一个进程，没有与集群建立联系 。 Spark Shell中已经默认将SparkContext类初始化为对象sc。用户代码如果需要用到，则直接应用sc即可 。 JobHistoryServer配置 修改spark-default.conf.template名称 mv spark-defaults.conf.template spark-defaults.conf 修改spark-default.conf文件，开启log 123vi spark-defaults.confspark.eventLog.enabled //truespark.eventLog.dir //hdfs://hadoop101:9000/directory（若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错） 注意：HDFS上的目录需要提前存在 修改spark-env.sh文件，添加如下配置 1234vi spark-env.shexport SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://hadoop101:9000/directory&quot; //若是hadoop中core-site.xml配置端口为8020则设置为8020而不是9000，否则出错 分发配置文件到其他虚拟机 12xsync spark-defaults.confxsync spark-env.sh 启动历史服务 sbin/start-history-server.sh 测试，执行任务长度 1234567bin/spark-submit \--class org.apache.spark.examples.SparkPi \--master spark://hadoop101:7077 \--executor-memory 1G \--total-executor-cores 2 \./examples/jars/spark-examples_2.11-2.4..jar \100 查看历史服务 在浏览器上输入hadoop101:4000查看 Yarn模式安装 修改hadoop配置文件yarn-site.xml，并添加如下内容 1234567891011vi yarn-site.xml&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; 修改spark-env.sh，添加如下配置 123vi spark-env.shYARN_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop HADOOP_CONF_DIR=/opt/module/hadoop-2.7.2/etc/hadoop 分发配置文件 12xsync /opt/module/hadoop-2.7.2/etc/hadoop/yarn-site.xmlxsync spark-env.sh]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark初识]]></title>
    <url>%2F2019%2F08%2F04%2FSpark%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spark简介(官网的解释Spark官网) Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。项目是用Scala进行编写。 Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLib、SparkR等子项目，Spark是基于内存计算的大数据并行计算框架。除了扩展了广泛使用的 MapReduce 计算模型，而且高效地支持更多计算模式，包括交互式查询和流处理。Spark 适用于各种各样原先需要多种不同的分布式平台的场景，包括批处理、迭代算法、交互式查询、流处理。通过在一个统一的框架下支持这些不同的计算，Spark 使我们可以简单而低耗地把各种处理流程整合在一起。而这样的组合，在实际的数据分析 过程中是很有意义的。不仅如此，Spark 的这种特性还大大减轻了原先需要对各种平台分 别管理的负担。 大一统的软件栈，各个组件关系密切并且可以相互调用，这种设计有几个好处：1、软件栈中所有的程序库和高级组件 都可以从下层的改进中获益。2、运行整个软件栈的代价变小了。不需要运 行 5 到 10 套独立的软件系统了，一个机构只需要运行一套软件系统即可。系统的部署、维护、测试、支持等大大缩减。3、能够构建出无缝整合不同处理模型的应用。 Spark内置项目如下： Spark Core:实现了 Spark 的基本功能，包含任务调度、内存管理、错误恢复、与存储系统 交互等模块。Spark Core 中还包含了对弹性分布式数据集(resilient distributed dataset，简称RDD)的 API 定义 。 Spark SQL:是 Spark 用来操作结构化数据的程序包。通过 Spark SQL，我们可以使用 SQL 或者 Apache Hive 版本的 SQL 方言(HQL)来查询数据。Spark SQL 支持多种数据源，比 如 Hive 表、Parquet 以及 JSON 等。 Spark Streaming:是 Spark 提供的对实时数据进行流式计算的组件。提供了用来操作数据流的 API，并且与 Spark Core 中的 RDD API 高度对应。 Spark MLlib:提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 Spark特点 快：与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中的。 易用：Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用：Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。 兼容性：Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 Spark角色及运行模式集群角色从物理部署层面上来看，Spark主要分为两种类型的节点，Master节点和Worker节点：Master节点主要运行集群管理器的中心化部分，所承载的作用是分配Application到Worker节点，维护Worker节点，Driver，Application的状态。Worker节点负责具体的业务运行。 从Spark程序运行的层面来看，Spark主要分为驱动器节点和执行器节点。 运行模式 Local模式：Local模式就是运行在一台计算机上的模式，通常就是用于在本机上练手和测试。它可以通过以下集中方式设置master。 local: 所有计算都运行在一个线程当中，没有任何并行计算，通常我们在本机执行一些测试代码，或者练手，就用这种模式; local[K]: 指定使用几个线程来运行计算，比如local[4]就是运行4个worker线程。通常我们的cpu有几个core，就指定几个线程，最大化利用cpu的计算能力; local[*]: 这种模式直接帮你按照cpu最多cores来设置线程数了。 Standalone模式：构建一个由Master+Slave构成的Spark集群，Spark运行在集群中。 Yarn模式：Spark客户端直接连接Yarn；不需要额外构建Spark集群。有yarn-client和yarn-cluster两种模式，主要区别在于：Driver程序的运行节点。 yarn-client：Driver程序运行在客户端，适用于交互、调试，希望立即看到app的输出。 yarn-cluster：Driver程序运行在由RM（ResourceManager）启动的AP（APPMaster）适用于生产环境。 Mesos模式：Spark客户端直接连接Mesos；不需要额外构建Spark集群。国内应用比较少，更多的是运用yarn调度。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
</search>
